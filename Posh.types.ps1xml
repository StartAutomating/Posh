<?xml version="1.0" encoding="utf-16"?>
<!-- Generated with EZOut 2.0.4: Install-Module EZOut or https://github.com/StartAutomating/EZOut -->
<Types>
  <Type>
    <Name>Posh</Name>
    <Members>
      <AliasProperty>
        <Name>Error</Name>
        <ReferencedMemberName>Errors</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Profile</Name>
        <ReferencedMemberName>Profiles</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Recommend</Name>
        <ReferencedMemberName>Recommends</ReferencedMemberName>
      </AliasProperty>
      <ScriptProperty>
        <Name>Errors</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Returns all errors
.DESCRIPTION
    Returns all errors from the current session
.EXAMPLE
    $Posh.Errors
#&gt;
$global:Error
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>ExecutionContext</Name>
        <GetScriptBlock>
                        $global:ExecutionContext
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>History</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the PowerShell History
.DESCRIPTION
    Gets the history of commands run in this PowerShell session.
.EXAMPLE
    $posh.History
.LINK
    Get-History
#&gt;
Get-History
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Host</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the PowerShell Host
.DESCRIPTION
    Gets the current PowerShell Host
.EXAMPLE
    $posh.Host

#&gt;
$global:host
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Jobs</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets PowerShell Jobs
.DESCRIPTION
    Gets PowerShell Background Jobs
.EXAMPLE
    $posh.Jobs
.Link
    Get-Job
.Link
    Start-Job
#&gt;
Get-Job
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Modules</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the loaded modules
.DESCRIPTION
    Gets the PowerShell modules loaded in the current session.
#&gt;
Get-Module
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>NET</Name>
        <GetScriptBlock>
                        if (-not $this.'.NET') {
    $this | Add-Member NoteProperty '.NET' -Value ([PSCustomObject]@{PSTypeName='Posh.NET'})
}

$this.'.NET'
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Process</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the PowerShell Process
.DESCRIPTION
    Gets the process currently hosting PowerShell
.EXAMPLE
    $posh.Process
#&gt;
Get-Process -id $PID
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Profiles</Name>
        <GetScriptBlock>
                        $profile
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Recommends</Name>
        <GetScriptBlock>
                        foreach ($module in $posh.Modules) {
    $module.Recommendation
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Runspace</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the PowerShell Runspaces
.DESCRIPTION
    Gets the current PowerShell Runspace.
.EXAMPLE
    $posh.Runspace
#&gt;
$host.Runspace
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.Commands</Name>
    <Members>
      <MemberSet>
        <Name>PSStandardMembers</Name>
        <Members>
          <PropertySet>
            <Name>DefaultDisplayPropertySet</Name>
            <ReferencedProperties>
              <Name>Count</Name>
              <Name>AliasCount</Name>
              <Name>ApplicationCount</Name>
              <Name>CmdletCount</Name>
              <Name>FunctionCount</Name>
            </ReferencedProperties>
          </PropertySet>
        </Members>
      </MemberSet>
      <AliasProperty>
        <Name>Aliases</Name>
        <ReferencedMemberName>Alias</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Applications</Name>
        <ReferencedMemberName>Application</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Cmdlets</Name>
        <ReferencedMemberName>Cmdlet</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Functions</Name>
        <ReferencedMemberName>Function</ReferencedMemberName>
      </AliasProperty>
      <ScriptMethod>
        <Name>FindExtensions</Name>
        <Script>
                        &lt;#
.SYNOPSIS

.DESCRIPTION

.EXAMPLE
    $posh.Commands.FindExtensions($posh, "$pwd")
#&gt;
$targetModules = @()
$targetPaths = @()
$loadedModules = Get-Module
foreach ($arg in $args) {
    if ($arg -is [Management.Automation.PSModuleInfo]) {
        $targetModules += $arg
    }
    elseif ($arg -is [IO.FileInfo] -or $arg -is [IO.DirectoryInfo]) {
        $targetPaths += $arg
    } 
    elseif ($arg -is [Management.Automation.PathInfo]) {
        $targetPaths += "$arg"
    }
    elseif ($arg -is [string]) {
        $argIsModule = 
            foreach ($module in $loadedModules) { if ($module.Name -like $arg) { $module}}
        if ($argIsModule) {
            $targetModules += $argIsModule
        } elseif (Test-Path $arg) {
            $targetPaths += $arg
        }
        
    }
}

if (-not $targetModules) { $targetModules = $posh.Modules}
$Splat = @{}
if ($targetPaths) {
    $Splat.FilePath = $targetPaths
}
foreach ($module in $targetModules) {
    # Aspect.ModuleExtendedCommand
    &amp; { 
    
        &lt;#
        .SYNOPSIS
            Returns a module's extended commands
        .DESCRIPTION
            Returns the commands or scripts in a module that match the module command pattern.
    
            Each returned script will be decorated with the typename(s) that match,
            so that the extended commands can be augmented by the extended types system.
        .LINK
            Aspect.ModuleExtensionPattern
        .EXAMPLE
            Aspect.ModuleExtensionCommand -Module PipeScript # Should -BeOfType ([Management.Automation.CommandInfo])
        #&gt;
        [Alias('Aspect.ModuleExtendedCommand')]
        param(
        # The name of a module, or a module info object.
        [Parameter(Mandatory,ValueFromPipelineByPropertyName)]
        [ValidateScript({
        $validTypeList = [System.String],[System.Management.Automation.PSModuleInfo]
        
        $thisType = $_.GetType()
        $IsTypeOk =
            $(@( foreach ($validType in $validTypeList) {
                if ($_ -as $validType) {
                    $true;break
                }
            }))
        
        if (-not $isTypeOk) {
            throw "Unexpected type '$(@($thisType)[0])'.  Must be 'string','psmoduleinfo'."
        }
        return $true
        })]
        
        $Module,
        
        # A list of commands.
        # If this is provided, each command that is a valid extension will be returned.
        [Parameter(ValueFromPipelineByPropertyName)]
        [Management.Automation.CommandInfo[]]
        $Commands,
    
        # The suffix to apply to each named capture.
        # Defaults to '_Command'
        [Parameter(ValueFromPipelineByPropertyName)]
        [string]
        $Suffix = '_Command',
    
        # The prefix to apply to each named capture. 
        [Parameter(ValueFromPipelineByPropertyName)]
        [string]
        $Prefix,
    
        # The file path(s).  If provided, will look for commands within these paths.
        [Parameter(ValueFromPipelineByPropertyName)]
        [Alias('Fullname')]    
        $FilePath,
    
        # The PowerShell command type.  If this is provided, will only get commands of this type.
        [Parameter(ValueFromPipelineByPropertyName)]
        [Management.Automation.CommandTypes]
        $CommandType,
    
        # The base PSTypeName(s).
        # If provided, any commands that match the pattern will apply these typenames, too.
        [string[]]
        $PSTypeName
        )
    
        process {        
            if ($Module -is [string]) {
                $Module = Get-Module $Module
            }
            $ModuleInfo = $module
    
            if (-not $ModuleInfo) { return }
            
            $ModuleCommandPattern = # Aspect.ModuleExtensionPattern
                                    &amp; { 
                                    
                                        &lt;#
                                        .SYNOPSIS
                                            Outputs a module's extension pattern
                                        .DESCRIPTION
                                            Outputs a regular expression that will match any possible pattern.
                                        .EXAMPLE
                                            Aspect.ModuleCommandPattern -Module PipeScript # Should -BeOfType ([Regex])
                                        #&gt;
                                        [Alias('Aspect.ModuleCommandPattern')]
                                        param(
                                        # The name of a module, or a module info object.
                                        [Parameter(Mandatory,ValueFromPipelineByPropertyName)]
                                        [ValidateScript({
                                        $validTypeList = [System.String],[System.Management.Automation.PSModuleInfo]
                                        
                                        $thisType = $_.GetType()
                                        $IsTypeOk =
                                            $(@( foreach ($validType in $validTypeList) {
                                                if ($_ -as $validType) {
                                                    $true;break
                                                }
                                            }))
                                        
                                        if (-not $isTypeOk) {
                                            throw "Unexpected type '$(@($thisType)[0])'.  Must be 'string','psmoduleinfo'."
                                        }
                                        return $true
                                        })]
                                        
                                        $Module,
                                    
                                        # The suffix to apply to each named capture.
                                        # Defaults to '_Command'
                                        [Parameter(ValueFromPipelineByPropertyName)]
                                        [string]
                                        $Suffix = '_Command',
                                    
                                        # The prefix to apply to each named capture. 
                                        [Parameter(ValueFromPipelineByPropertyName)]
                                        [string]
                                        $Prefix
                                        )
                                    
                                        process {
                                            if ($Module -is [string]) {
                                                $Module = Get-Module $Module
                                            }
                                            $ModuleInfo = $module
                                    
                                    
                                            #region Search for Module Extension Types
                                            if (-not $ModuleInfo) { return }
                                            $ModuleExtensionTypes = # Aspect.ModuleExtensionTypes
                                                                    &amp; { 
                                                                    
                                                                        &lt;#
                                                                        .SYNOPSIS
                                                                            Outputs a module's extension types
                                                                        .DESCRIPTION
                                                                            Outputs the extension types defined in a module's manifest.
                                                                        .EXAMPLE
                                                                            # Outputs a PSObject with information about extension command types.
                                                                            
                                                                            # The two primary pieces of information are the `.Name` and `.Pattern`.
                                                                            Aspect.ModuleExtensionType -Module PipeScript # Should -BeOfType ([PSObject])
                                                                        #&gt;
                                                                        [Alias('Aspect.ModuleCommandTypes','Aspect.ModuleCommandType','Aspect.ModuleExtensionTypes')]
                                                                        param(
                                                                        # The name of a module, or a module info object.
                                                                        [Parameter(Mandatory,ValueFromPipelineByPropertyName)]
                                                                        [ValidateScript({
                                                                        $validTypeList = [System.String],[System.Management.Automation.PSModuleInfo]
                                                                        
                                                                        $thisType = $_.GetType()
                                                                        $IsTypeOk =
                                                                            $(@( foreach ($validType in $validTypeList) {
                                                                                if ($_ -as $validType) {
                                                                                    $true;break
                                                                                }
                                                                            }))
                                                                        
                                                                        if (-not $isTypeOk) {
                                                                            throw "Unexpected type '$(@($thisType)[0])'.  Must be 'string','psmoduleinfo'."
                                                                        }
                                                                        return $true
                                                                        })]
                                                                        
                                                                        $Module
                                                                        )
                                                                    
                                                                        begin {
                                                                            $ExtensionCollectionNames = 
                                                                                "Extension", "Command", "Cmdlet", "Function", "Alias", "Script", "Application", "File","Configuration"
                                                                            $ExtensionCollectionNames = @($ExtensionCollectionNames -replace '.+$','${0}Type') + @($ExtensionCollectionNames -replace '.+$','${0}Types')
                                                                        }
                                                                    
                                                                        process {
                                                                            #region Resolve Module Info
                                                                            if ($Module -is [string]) {
                                                                                $Module = Get-Module $Module
                                                                            }
                                                                            $ModuleInfo = $module                
                                                                            if (-not $ModuleInfo) { return }
                                                                            #endregion Resolve Module Info
                                                                    
                                                                            #region Check Cache and Hopefully Return
                                                                            if (-not $script:ModuleExtensionTypeCache) {
                                                                                $script:ModuleExtensionTypeCache = @{}
                                                                            }
                                                                            
                                                                            if ($script:ModuleExtensionTypeCache[$ModuleInfo]) {
                                                                                return $script:ModuleExtensionTypeCache[$ModuleInfo]
                                                                            }
                                                                            #endregion Check Cache and Hopefully Return
                                                                    
                                                                            #region Find Extension Types
                                                                            $modulePrivateData  = $ModuleInfo.PrivateData
                                                                    
                                                                            $SortedExtensionTypes = [Ordered]@{}
                                                                            foreach ($TypeOfExtensionCollection in $ExtensionCollectionNames) {
                                                                                $moduleExtensionTypes = 
                                                                                    if ($modulePrivateData.$TypeOfExtensionCollection) {
                                                                                        $modulePrivateData.$TypeOfExtensionCollection
                                                                                    } elseif ($modulePrivateData.PSData.$TypeOfExtensionCollection) {
                                                                                        $modulePrivateData.PSData.$TypeOfExtensionCollection
                                                                                    } else {
                                                                                        $null
                                                                                    }
                                                                    
                                                                                if (-not $moduleExtensionTypes) { continue } 
                                                                    
                                                                                foreach ($commandType in @($ModuleExtensionTypes.GetEnumerator() | Sort-Object Key)) {
                                                                                    if ($commandType.Value -is [Collections.IDictionary]) {
                                                                                        if (-not $commandType.Value.Name) {
                                                                                            $commandType.Value["Name"] = $commandType.Key
                                                                                        }
                                                                                        if (-not $commandType.Value.PSTypeName) {
                                                                                            $commandType.Value["PSTypeName"] = "$($module.Name).ExtensionCommandType"
                                                                                        }
                                                                                        $SortedExtensionTypes[$commandType.Name] = $commandType.Value
                                                                                    } else {
                                                                                        $SortedExtensionTypes[$commandType.Name] = [Ordered]@{
                                                                                            PSTypeName = "$($module.Name).ExtensionCommandType"
                                                                                            Name    = $commandType.Key
                                                                                            Pattern = $commandType.Value
                                                                                        }
                                                                                    }
                                                                                    if ($TypeOfExtensionCollection -notmatch '(?&gt;Extension|Command|Cmdlet)') {
                                                                                        $SortedExtensionTypes[$commandType.Name].CommandType = $TypeOfExtensionCollection -replace 'Type(?:s)?$'
                                                                                    } elseif ($TypeOfExtensionCollection -match 'Cmdlet') {
                                                                                        $SortedExtensionTypes[$commandType.Name].CommandType = "(?&gt;Alias|Function|Filter|Cmdlet)"
                                                                                    }
                                                                                }
                                                                            }
                                                                            
                                                                            $SortedExtensionTypes.PSTypeName="$($Module.Name).ExtensionCommandTypes"
                                                                            
                                                                            $script:ModuleExtensionTypeCache[$ModuleInfo] = [PSCustomObject]$SortedExtensionTypes
                                                                            $script:ModuleExtensionTypeCache[$ModuleInfo]
                                                                            #endregion Find Extension Types
                                                                    
                                                                        }    
                                                                    
                                                                     } -Module $moduleInfo
                                    
                                            
                                            if (-not $ModuleExtensionTypes) { return }
                                                
                                            # With some clever understanding of Regular expressions, we can make match any/all of our potential command types.
                                            # Essentially: Regular Expressions can look ahead (matching without changing the position), and be optional.
                                            # So we can say "any/all" by making a series of optional lookaheads.
                                            
                                            # We'll go thru each pattern in order
                                            $combinedRegex = @(foreach ($categoryExtensionTypeInfo in @($ModuleExtensionTypes.psobject.properties)) {
                                                $categoryPattern = $categoryExtensionTypeInfo.Value.Pattern                
                                                # ( and skip anyone that does not have a pattern)
                                                if (-not $categoryPattern) { continue } 
                                    
                                                '(?=' + # Start a lookahead
                                                    '.{0,}' + # match any or no characters
                                                    # followed by the command pattern
                                                    "(?&lt;$Prefix$($categoryExtensionTypeInfo.Name -replace '\p{P}', '_')$Suffix&gt;$categoryPattern)" +
                                                    ')?' # made optional                            
                                            }) -join [Environment]::NewLine
                                    
                                            # Now that we've combined the whole thing, make it a Regex and output it.        
                                            [Regex]::new("$combinedRegex", 'IgnoreCase,IgnorePatternWhitespace','00:00:01')
                                        }
                                    
                                     } $ModuleInfo -Prefix $prefix -Suffix $Suffix
            $ModuleCommandTypes   = # Aspect.ModuleExtensionType
                                    &amp; { 
                                    
                                        &lt;#
                                        .SYNOPSIS
                                            Outputs a module's extension types
                                        .DESCRIPTION
                                            Outputs the extension types defined in a module's manifest.
                                        .EXAMPLE
                                            # Outputs a PSObject with information about extension command types.
                                            
                                            # The two primary pieces of information are the `.Name` and `.Pattern`.
                                            Aspect.ModuleExtensionType -Module PipeScript # Should -BeOfType ([PSObject])
                                        #&gt;
                                        [Alias('Aspect.ModuleCommandTypes','Aspect.ModuleCommandType','Aspect.ModuleExtensionTypes')]
                                        param(
                                        # The name of a module, or a module info object.
                                        [Parameter(Mandatory,ValueFromPipelineByPropertyName)]
                                        [ValidateScript({
                                        $validTypeList = [System.String],[System.Management.Automation.PSModuleInfo]
                                        
                                        $thisType = $_.GetType()
                                        $IsTypeOk =
                                            $(@( foreach ($validType in $validTypeList) {
                                                if ($_ -as $validType) {
                                                    $true;break
                                                }
                                            }))
                                        
                                        if (-not $isTypeOk) {
                                            throw "Unexpected type '$(@($thisType)[0])'.  Must be 'string','psmoduleinfo'."
                                        }
                                        return $true
                                        })]
                                        
                                        $Module
                                        )
                                    
                                        begin {
                                            $ExtensionCollectionNames = 
                                                "Extension", "Command", "Cmdlet", "Function", "Alias", "Script", "Application", "File","Configuration"
                                            $ExtensionCollectionNames = @($ExtensionCollectionNames -replace '.+$','${0}Type') + @($ExtensionCollectionNames -replace '.+$','${0}Types')
                                        }
                                    
                                        process {
                                            #region Resolve Module Info
                                            if ($Module -is [string]) {
                                                $Module = Get-Module $Module
                                            }
                                            $ModuleInfo = $module                
                                            if (-not $ModuleInfo) { return }
                                            #endregion Resolve Module Info
                                    
                                            #region Check Cache and Hopefully Return
                                            if (-not $script:ModuleExtensionTypeCache) {
                                                $script:ModuleExtensionTypeCache = @{}
                                            }
                                            
                                            if ($script:ModuleExtensionTypeCache[$ModuleInfo]) {
                                                return $script:ModuleExtensionTypeCache[$ModuleInfo]
                                            }
                                            #endregion Check Cache and Hopefully Return
                                    
                                            #region Find Extension Types
                                            $modulePrivateData  = $ModuleInfo.PrivateData
                                    
                                            $SortedExtensionTypes = [Ordered]@{}
                                            foreach ($TypeOfExtensionCollection in $ExtensionCollectionNames) {
                                                $moduleExtensionTypes = 
                                                    if ($modulePrivateData.$TypeOfExtensionCollection) {
                                                        $modulePrivateData.$TypeOfExtensionCollection
                                                    } elseif ($modulePrivateData.PSData.$TypeOfExtensionCollection) {
                                                        $modulePrivateData.PSData.$TypeOfExtensionCollection
                                                    } else {
                                                        $null
                                                    }
                                    
                                                if (-not $moduleExtensionTypes) { continue } 
                                    
                                                foreach ($commandType in @($ModuleExtensionTypes.GetEnumerator() | Sort-Object Key)) {
                                                    if ($commandType.Value -is [Collections.IDictionary]) {
                                                        if (-not $commandType.Value.Name) {
                                                            $commandType.Value["Name"] = $commandType.Key
                                                        }
                                                        if (-not $commandType.Value.PSTypeName) {
                                                            $commandType.Value["PSTypeName"] = "$($module.Name).ExtensionCommandType"
                                                        }
                                                        $SortedExtensionTypes[$commandType.Name] = $commandType.Value
                                                    } else {
                                                        $SortedExtensionTypes[$commandType.Name] = [Ordered]@{
                                                            PSTypeName = "$($module.Name).ExtensionCommandType"
                                                            Name    = $commandType.Key
                                                            Pattern = $commandType.Value
                                                        }
                                                    }
                                                    if ($TypeOfExtensionCollection -notmatch '(?&gt;Extension|Command|Cmdlet)') {
                                                        $SortedExtensionTypes[$commandType.Name].CommandType = $TypeOfExtensionCollection -replace 'Type(?:s)?$'
                                                    } elseif ($TypeOfExtensionCollection -match 'Cmdlet') {
                                                        $SortedExtensionTypes[$commandType.Name].CommandType = "(?&gt;Alias|Function|Filter|Cmdlet)"
                                                    }
                                                }
                                            }
                                            
                                            $SortedExtensionTypes.PSTypeName="$($Module.Name).ExtensionCommandTypes"
                                            
                                            $script:ModuleExtensionTypeCache[$ModuleInfo] = [PSCustomObject]$SortedExtensionTypes
                                            $script:ModuleExtensionTypeCache[$ModuleInfo]
                                            #endregion Find Extension Types
                                    
                                        }    
                                    
                                     } $ModuleInfo
            
            $commands    =
                @(
                if ($PSBoundParameters['Commands']) {
                    $commands
                }
                elseif ($PSBoundParameters['FilePath']) {
                    if (-not $commandType) {
                        $commandType = 'Application,ExternalScript'
                    }
                    
                    $shouldRecurse = $($PSBoundParameters['FilePath'] -notmatch '^\.\\') -as [bool]
                        
                    foreach ($file in Get-ChildItem -File -Path $PSBoundParameters['FilePath'] -Recurse:$shouldRecurse ) {
                        $ExecutionContext.SessionState.InvokeCommand.GetCommand($file.FullName, $commandType)
                    }
                } else {
                    if (-not $CommandType) {
                        $commandType = 'Function,Alias,Filter,Cmdlet'
                    }
                    $ExecutionContext.SessionState.InvokeCommand.GetCommands('*', $commandType, $true)
                })
    
            :nextCommand foreach ($cmd in $commands) {            
                $matched = $ModuleCommandPattern.Match("$cmd")
                if (-not $matched.Success) { continue }
                $NamedGroupMatch = $false
                :nextCommandType foreach ($group in $matched.Groups) {
                    if (-not $group.Success) { continue }
                    if ($null -ne ($group.Name -as [int])) { continue }                
                    $CommandTypeName     = $group.Name.Replace('_','.')
                    $ThisCommandsType    = $ModuleCommandTypes.($group.Name -replace "^$prefix" -replace "$suffix$")
                    if ($ThisCommandsType) {
                        $ThisTypeFilter = @($ThisCommandsType.CommandType,$ThisCommandsType.CommandTypes -ne $null)[0]
                        if ($ThisTypeFilter -and ($cmd.CommandType -notmatch $ThisTypeFilter)) {
                            continue nextCommandType
                        }
                        $ThisExcludeFilter = @($ThisCommandsType.ExcludeCommandType,$ThisCommandsType.ExcludeCommandTypes -ne $null)[0]
                        if ($ThisExcludeFilter -and ($cmd.CommandType -match $ThisExcludeFilter)) {
                            continue nextCommandType
                        }
                    }
                    $NamedGroupMatch     = $true
                    if ($PSTypeName) {
                        foreach ($psuedoType in $PSTypeName) {
                            if ($cmd.pstypenames -notcontains $psuedoType) {
                                $cmd.pstypenames.insert(0, $psuedoType)        
                            }
                        }
                    }
                    if ($cmd.pstypenames -notcontains $CommandTypeName) {
                        $cmd.pstypenames.insert(0, $CommandTypeName)
                    }
                }
                if ($NamedGroupMatch) {
                    $cmd
                }
            }
        }
    
     } -Module $module @Splat
}

                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>AliasCount</Name>
        <GetScriptBlock>
                        @($this.Alias).Count
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>ApplicationCount</Name>
        <GetScriptBlock>
                        @($this.Application).Count
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>CmdletCount</Name>
        <GetScriptBlock>
                        @($this.Alias).Count
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Count</Name>
        <GetScriptBlock>
                        @($this.All).Count
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Extended</Name>
        <GetScriptBlock>
                        $this.FindExtensions()

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>FunctionCount</Name>
        <GetScriptBlock>
                        @($this.Function).Count
                    </GetScriptBlock>
      </ScriptProperty>
      <NoteProperty>
        <Name>DefaultDisplay</Name>
        <Value>Count
AliasCount
ApplicationCount
CmdletCount
FunctionCount</Value>
      </NoteProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.Errors</Name>
    <Members>
      <ScriptMethod>
        <Name>LineLike</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Filters errors by line wildcard
.DESCRIPTION
    Filters entries in $Error for items that a .Line like a wildcard.
.EXAMPLE
    $error.LineLike("Get-*")
#&gt;
param(
# A wildcard pattern.
[string]
$Like
)

,@(foreach ($err in $this) {
    if ($err.InvocationInfo.Line -like $Like) {
        $err
    }
})
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>LineMatch</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Filters errors by command pattern
.DESCRIPTION
    Filters entries in $Error for items that have a .CommandLine matching the pattern.
.EXAMPLE
    $error.LineMatc("^Get")
#&gt;
param(
# A regular expression.
$Match
)

,@(foreach ($err in $this) {
    if ($err.InvocationInfo.Line -match $match) {
        $err
    }
})
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>ByLine</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets errors by line
.DESCRIPTION
    Gets all lines that produced errors
.EXAMPLE
    $error.ByLine    
#&gt;
$errorsByLine = 
    [Collections.Generic.Dictionary[
        string,
        [Collections.Generic.List[psobject]]
    ]]::new([System.StringComparer]::OrdinalIgnoreCase)


foreach ($err in $this) {
    
    $errLine = $err.InvocationInfo.Line
    if (-not $errLine) { continue }
    if (-not $errorsByLine[$errLine]) {
        $errorsByLine[$errLine] = [Collections.Generic.List[psobject]]::new()
    }
    $null = $errorsByLine[$errLine].Add($err)
}
$errorsByLine

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>ByType</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets Errors By Type
.DESCRIPTION
    Returns all errors, by type of error.
.EXAMPLE
    $posh.Errors.ByType
#&gt;
$errorsByType = 
    [Collections.Generic.Dictionary[
        type,
        [Collections.Generic.List[psobject]]
    ]]::new()


foreach ($err in $this) {
    
    $exceptionType = if ($err.Exception) {
        $err.Exception.GetType()
    } else {
        $err.GetType()
    }
    if (-not $errorsByType[$exceptionType]) {
        $errorsByType[$exceptionType] = [Collections.Generic.List[psobject]]::new()
    }
    $null = $errorsByType[$exceptionType].Add($err)
}
$errorsByType

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>History</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets Error History
.DESCRIPTION
    Gets the history items associated with PowerShell Errors
.EXAMPLE
    $Error.History
#&gt;
$historyIDS = @(foreach ($err in $this) {
    if ($err.InvocationInfo.HistoryId -gt 0) {
        $err.InvocationInfo.HistoryId
    }
})

Get-History -Id $historyIDS
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.ExtensionCollection</Name>
    <Members>
      <ScriptMethod>
        <Name>Refresh</Name>
        <Script>
                        $this | Add-Member NoteProperty '.Cache' @() -Force
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>All</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets all items in an extension collection.
.DESCRIPTION
    Gets all items in a collection of extended commands.
#&gt;
if (-not $this.'.Cache') {
    if (-not $this.'.Module') { return @() }

    $findExtensionArgs  = @($this.'.Module') + @($this.'.Path')
    $allExtensionsFound = 
        @(:nextExtension 
            foreach ($foundExtension in 
                $posh.Commands.FindExtensions.Invoke($findExtensionArgs)
            ) 
            {
            if ($this.'.CommandType') {
                foreach ($typename in $this.'.CommandType') {
                    if ($foundExtension.pstypenames -contains $typename) {
                        $foundExtension
                        continue nextExtension
                    }
                }
            } else {
                $foundExtension
            }
            }
        )
    $this |
        Add-Member NoteProperty '.Cache' $allExtensionsFound -Force
}

return $this.'.Cache'
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>CommandType</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets an extension collection's CommandType
.DESCRIPTION
    Gets the extended CommandTypes(s) that are stored in an extension collection.

    CommandTypes can be defined in a module's manifest.
#&gt;
return $this.'.CommandType'
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets an extension collection's command type
.DESCRIPTION
    Sets the extended command types in an extension collection.
#&gt;
param(
# The path.  If this is empty all extended commands will be present in the collection
[string[]]
$CommandType
)

Add-Member -InputObject $this -MemberType NoteProperty -Name '.CommandType' -Value $CommandType -Force
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Count</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the extension count.
.DESCRIPTION
    Gets the count of all extensions in a collection.
#&gt;
$this.All.Length
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Module</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets an extension collection's module
.DESCRIPTION
    Gets the module that defines extended types in an extension collection.
#&gt;
return $this.'.Module'
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets an extension collection's module
.DESCRIPTION
    Sets the module that defines extended command types in an extension collection.
#&gt;
param(
# The module.
[Management.Automation.PSModuleInfo]
$Module
)

Add-Member -InputObject $this -MemberType NoteProperty -Name '.Module' -Value $module -Force
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Path</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets an extension collection's Path
.DESCRIPTION
    Gets the Path(s) that store extensions in an extension collection.        
#&gt;
return $this.'.Path'
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets an extension collection's path
.DESCRIPTION
    Sets the path that defines extended command types in an extension collection.
#&gt;
param(
# The path.  If this is empty, only extensions that are functions or aliases will be found.
[string[]]
$Path
)

Add-Member -InputObject $this -MemberType NoteProperty -Name '.Path' -Value $Path -Force
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Random</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a random extended command
.DESCRIPTION
    Gets a random extended command from an ExtensionCollection.
#&gt;
$this.All | Get-Random
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.Host</Name>
    <Members>
      <ScriptMethod>
        <Name>Choose</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Prompts a choice
.DESCRIPTION
    Prompts a choice between multiple options.

    An option can be a string, hashtable, or scriptblock.
    
    Hashtables keys and arrays will become a list of possible choices.
    
    Strings will be outputted as a message.

    A boolean will indicate multiple items can be chosen.
.Example
    $Posh.Host.Choose(
        "Cake Or Death?", 
        @("Cake", "Death")
    )
#&gt;
param()

$captionAndMessage = @()

$choiceList = @()

$defaultChoices = @()

$multiselect = $false

foreach ($argument in $args) {
    if ($argument -is [string]) {
        $captionAndMessage += $argument
    }
    if ($argument -is [bool] -and $argument) {
        $multiselect = $true
    }
    
    if ($argument -is [Collections.IDictionary]) {
        if ($argument -is [hashtable]) {
            $choiceList += @($argument.GetEnumerator() | Sort-Object Key).Key
        } else {
            $choiceList += @($argument.GetEnumerator()).Key
        }
    } elseif ($argument -is [object[]]) {
        if ($argument -as [int[]]) {
            $defaultChoices += $argument
        } else {
            $choiceList += $argument
        }        
    }
}

$choiceList = @(
    foreach ($potentialChoice in $choiceList) {
        [Management.Automation.Host.ChoiceDescription]::new("$potentialChoice")
    }
)

if (-not $choiceList) { return }


$caption, $message = $captionAndMessage
if ($defaultChoices) {
    if (-not $multiselect) {
        $defaultChoices = $defaultChoices[0]            
        $choice = $host.UI.PromptForChoice($caption, $message, $choiceList, $defaultChoices)
    } else {            
        $choice = $host.UI.PromptForChoice($caption, $message, $choiceList, $defaultChoices)
    }
    
} else {
    $choice = 
    if ($multiselect) {
        $host.UI.PromptForChoice($caption, $message, $choiceList, [int[]]@(0))
    } else {
        $host.UI.PromptForChoice($caption, $message, $choiceList, 0)
    }
    
}

if ($choice -ne -1) {
    $choiceList[$choice].Label
}    


                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>Cursor</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the cursor
.DESCRIPTION
    Gets the console cursor.
.EXAMPLE
    $Host.Cursor
.EXAMPLE
    $Posh.Host.Cursor
.EXAMPLE
    $Posh.Cursor.Position
#&gt;
return ([PSCustomObject]@{PSTypeName='Posh.Host.Cursor'})
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Height</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the height of the host
.DESCRIPTION
    Gets the height of the host (in characters).
.EXAMPLE
    $posh.Host.Height
.EXAMPLE
    $Host.Height
#&gt;
$this.UI.RawUI.BufferSize.Height
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Keyboard</Name>
        <GetScriptBlock>
                        if (-not $this.'.Keyboard') {
    Add-Member -InputObject $this -MemberType NoteProperty -Name '.Keyboard' -Value (
        [PSCustomObject]@{PSTypeName='Posh.Host.Keyboard'}
    ) -Force
}
$this.'.Keyboard'
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Title</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the host's title
.DESCRIPTION
    Gets the host's window title.
.EXAMPLE
    $Posh.Title
#&gt;
$this.UI.RawUI.WindowTitle

                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the host's title
.DESCRIPTION
    Sets the host's window title.

    Unfortunately, this will be ignored if running in Visual Studio Code.
.EXAMPLE
    $Posh.Title = "Sup?"
#&gt;
param(
[string]
$Title
)
$this.UI.RawUI.WindowTitle = $title

                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Width</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the Width of the host
.DESCRIPTION
    Gets the Width of the host (in characters).
.EXAMPLE
    $posh.Host.Width
.EXAMPLE
    $Host.Width
#&gt;
$this.UI.RawUI.BufferSize.Width
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.Host.Cursor</Name>
    <Members>
      <AliasProperty>
        <Name>Left</Name>
        <ReferencedMemberName>Back</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Right</Name>
        <ReferencedMemberName>Forward</ReferencedMemberName>
      </AliasProperty>
      <ScriptMethod>
        <Name>Back</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Moves the cursor back
.DESCRIPTION
    Moves the cursor N (default 1) cells back.    
    If the cursor is already at the edge of the screen, this has no effect.
.NOTES
    This method returns an escape sequence (it should be invisible).
#&gt;
param(
    # How far the cursor should move.
    [Alias('N')]
    [ValidateRange(1,1024)]
    [int]$Distance = 1
)

"`e[${Distance}D"



                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Down</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Moves the cursor down
.DESCRIPTION
    Moves the cursor N (default 1) cells down.    
    If the cursor is already at the edge of the screen, this has no effect.
.NOTES
    This method returns an escape sequence (it should be invisible).
#&gt;
param(
    # How far the cursor should move    
    [ValidateRange(1,1024)]
    [int]$Distance = 1
)

"`e[${Distance}B"

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Forward</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Moves the cursor forward
.DESCRIPTION
    Moves the cursor N (default 1) cells back.    
    If the cursor is already at the edge of the screen, this has no effect.  
.NOTES
    This method returns an escape sequence (it should be invisible).
#&gt;
param(
    # How far the cursor should move
    [Alias('N')]    
    [ValidateRange(1,1024)]
    [int]$Distance = 1
)

"`e[${Distance}C"



                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Hide</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Hides the cursor
.DESCRIPTION
    Hides the cursor.  This is not supported in all terminals.
.NOTES
    This method returns an escape sequence (it should be invisible).
#&gt;
param()

"`e[25l"

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>PageDown</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Pages the cursor down
.DESCRIPTION
    Pages the cursor N (default 1) pages down.  New lines are added at the top.    
.NOTES
    This method returns an escape sequence (it should be invisible).
#&gt;
param(
    # How far the cursor should move
    [Alias('Rows')]
    [ValidateRange(1,1024)]
    [int]$Distance = 1
)

[Console]::Write("`e[${Distance}T")

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>PageUp</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Pages the cursor up.
.DESCRIPTION
    Pages the cursor N (default 1) pages up.  New lines are added at the bottom.    
.NOTES
    This method returns an escape sequence (it should be invisible).
#&gt;
param(
    # How far the cursor should move
    [Alias('Rows')]
    [ValidateRange(1,1024)]
    [int]$Distance = 1
)

[Console]::Write("`e[${Distance}S")



                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>SetPosition</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Sets the cursor position.
.DESCRIPTION
    Sets the position of the cursor.  This is not supported in all terminals.

    The position can be provided as a pair of integers.  
    
    The first integer will be the row, the second integer will be the column.
    
    The position can also be provided as an object with any of the following properties:

    * X/Column/Left
    * Y/Row/Top
.NOTES
    This method returns an escape sequence (it should be invisible).
#&gt;

$argList = @($args | . { process { $_ }})


$coordinates = 
    if ($argList -as [int[]]) {
        $argList -as [int[]]
    }
    elseif ($argList.Length -eq 1) {
        $arg = $args[0]
        
        if ($arg.Y) {
            $arg.Y
        }
        elseif ($arg.Row) {
            $arg.Row
        }
        elseif ($arg.Top) {
            $arg.Top
        }

        if ($arg.X) {
            $arg.X
        }
        elseif ($arg.Column) {
            $arg.Column
        }
        elseif ($arg.Left) {
            $arg.Left
        }
    }

if ($coordinates -and $coordinates.Length -eq 2) {    
    "`e[$($coordinates[0]);$($coordinates[1])H"
}


                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Show</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Shows the cursor
.DESCRIPTION
    Shows the cursor.  This is not supported in all terminals.
.NOTES
    This method returns an escape sequence (it should be invisible).
#&gt;
param()

"`e[25h"

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Up</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Moves the cursor up
.DESCRIPTION
    Moves the cursor N (default 1) cells up.    
    If the cursor is already at the edge of the screen, this has no effect.
#&gt;
param(
    # How far the cursor should move
    [Alias('N')]
    [ValidateRange(1,1024)]
    [int]$Distance = 1
)

"`e[${Distance}A"



                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>Position</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the cursor position
.DESCRIPTION
    Gets the cursor position
.EXAMPLE
    $Host.Cursor.Position
#&gt;

if ($host.UI.RawUI.CursorPosition) {
    # In the "really" category, CursorPosition is zero-index, where as actual cursors in a terminal are 1-indexed.
    [PSCustomObject][Ordered]@{
        PSTypeName = 'Posh.Host.Cursor.Position'
        Row    = ($host.UI.RawUI.CursorPosition.Y + 1)
        Column = ($host.UI.RawUI.CursorPosition.X + 1)
    }
}

                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.Host.Keyboard</Name>
    <Members>
      <ScriptProperty>
        <Name>KeyDown</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the current KeyDown
.DESCRIPTION
    Gets the current KeyDown
.EXAMPLE
    $Posh.Host.Keyboard.KeyDown # Will almost always be enter, because you just ran it
#&gt;
while ($host.UI.RawUI.KeyAvailable) { 
    $host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>KeyPress</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the current KeyPress
.DESCRIPTION
    Gets the currently pressed key
.EXAMPLE
    $Posh.Host.Keyboard.KeyPress # Will almost always be enter, because you just ran it
#&gt;
while ($host.UI.RawUI.KeyAvailable) { 
    $host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown,IncludeKeyUp')
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>KeyUp</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the current KeyUp
.DESCRIPTION
    Gets the current KeyUp event
.EXAMPLE
    $Posh.Host.Keyboard.KeyUp # Will almost always be enter, because you just ran it
#&gt;
while ($host.UI.RawUI.KeyAvailable) { 
    $host.UI.RawUI.ReadKey('NoEcho,IncludeKeyUp')
} 
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.Host.UI</Name>
    <Members>
      <AliasProperty>
        <Name>Borders</Name>
        <ReferencedMemberName>Boxes</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Box</Name>
        <ReferencedMemberName>Boxes</ReferencedMemberName>
      </AliasProperty>
      <ScriptProperty>
        <Name>Boxes</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a collection of boxes
.DESCRIPTION
    Gets a collection of box shapes that can be used to render a user interface.
.EXAMPLE
    $Posh.Host.UI.Boxes
#&gt;
if (-not $this.'.Boxes') {
    Add-Member -InputObject $this -MemberType NoteProperty -Name '.Boxes' -Value (
        [PSCustomObject]@{PSTypeName='Posh.Host.UI.Boxes'}
    ) -Force
}
$this.'.Boxes'
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Cursor</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the cursor
.DESCRIPTION
    Gets the console cursor.
.EXAMPLE
    $Host.UI.Cursor
.EXAMPLE
    $Posh.Host.UI.Cursor
.EXAMPLE
    $Posh.Host.UI.Cursor.Position
#&gt;
return ([PSCustomObject]@{PSTypeName='Posh.Host.Cursor'})
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.Host.UI.Box</Name>
    <Members>
      <ScriptProperty>
        <Name>BottomLeft</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a box's Bottom Left character
.DESCRIPTION
    Gets the Bottom Left character in a box
#&gt;

$theseLines = @($this -split '[\r\n]+' -ne '')

if (-not $theseLines) { return }
$theseLines[-1].Substring(0,1)


                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>BottomMiddle</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a box's Bottom Middle character
.DESCRIPTION
    Gets the Bottom Middle character in a box
#&gt;
$theseLines = @($this -split '[\r\n]+' -ne '')

if (-not $theseLines) { return }
    $theseLines[-1][
        [Math]::Floor($theseLines[-1].Length / 2)
    ]    



                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>BottomRight</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a box's Bottom Right character
.DESCRIPTION
    Gets the Bottom Right character in a box
#&gt;

$theseLines = @($this -split '[\r\n]+' -ne '')

if (-not $theseLines) { return }
$theseLines[-1].Substring($theseLines[-1].Length - 1)


                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>TopLeft</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a box's TopLeft character
.DESCRIPTION
    Gets the TopLeft character in a box
#&gt;
$theseLines = @($this -split '[\r\n]+' -ne '')

if (-not $theseLines) { return }
$theseLines[0].Substring(0,1)


                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>TopMiddle</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a box's TopMiddle character
.DESCRIPTION
    Gets the TopMiddle character in a box
#&gt;

$theseLines = @($this -split '[\r\n]+' -ne '')

if (-not $theseLines) { return }
$theseLines[0][
    [Math]::Floor($theseLines[0].Length / 2)
]    



                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>TopRight</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a box's Top Right character
.DESCRIPTION
    Gets the Top Right character in a box
#&gt;

$theseLines = @($this -split '[\r\n]+' -ne '')

if (-not $theseLines) { return }
$theseLines[0].Substring($theseLines[0].Length - 1)


                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.Host.UI.Boxes</Name>
    <Members>
      <ScriptMethod>
        <Name>New</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Creates a new box
.DESCRIPTION
    Creates a new box, based off of a box shape name.
#&gt;
param(
# The name of the box shape name.
[Parameter(Mandatory)]
[string]
$BoxName
)

if ($this.$BoxName -is [string]) {
    $newBoxObject = [PSObject]::new("$($this.$BoxName)")
    $newBoxObject.pstypenames.insert(0,'Posh.Host.UI.Box')
    $newBoxObject
}
                    </Script>
      </ScriptMethod>
      <NoteProperty>
        <Name>Double</Name>
        <Value>╔═╦═╗
║ ║ ║
╠═╬═╣
║ ║ ║
╚═╩═╝</Value>
      </NoteProperty>
      <NoteProperty>
        <Name>DoubleColumns</Name>
        <Value>╓─╥─╖
║ ║ ║
╟─╫─╢
║ ║ ║
╙─╨─╜</Value>
      </NoteProperty>
      <NoteProperty>
        <Name>DoubleRows</Name>
        <Value>╒═╤═╕
│ │ │
╞═╪═╡
│ │ │
╘═╧═╛
</Value>
      </NoteProperty>
      <NoteProperty>
        <Name>Heavy</Name>
        <Value>┏━┳━┓
┃ ┃ ┃
┣━╋━┫
┃ ┃ ┃
┗━┻━┛
</Value>
      </NoteProperty>
      <NoteProperty>
        <Name>HeavyDash</Name>
        <Value>┌╌┬╌┐
╎ │ ╎
├─┼─┤
╎ │ ╎
└╌┴╌┘
</Value>
      </NoteProperty>
      <NoteProperty>
        <Name>HeavyQuadDash</Name>
        <Value>┏┉┳┉┓
┋ ┃ ┋
┣┉╋┉┫
┋ ┃ ┋
┗┉┻┉┛
</Value>
      </NoteProperty>
      <NoteProperty>
        <Name>HeavyTripleDash</Name>
        <Value>┏┅┳┅┓
┇ ┃ ┇
┣┅╋┅┫
┇ ┃ ┇
┗┅┻┅┛
</Value>
      </NoteProperty>
      <NoteProperty>
        <Name>Light</Name>
        <Value>┌─┬─┐
│ │ │
├─┼─┤
│ │ │
└─┴─┘
</Value>
      </NoteProperty>
      <NoteProperty>
        <Name>LightDash</Name>
        <Value>┌╌┬╌┐
╎ │ ╎
├╌┼╌┤
╎ │ ╎
└╌┴╌┘
</Value>
      </NoteProperty>
      <NoteProperty>
        <Name>LightQuadDash</Name>
        <Value>┌┈┬┈┐
┊ │ ┊
├┈┼┈┤
┊ │ ┊
└┈┴┈┘
</Value>
      </NoteProperty>
      <NoteProperty>
        <Name>LightRound</Name>
        <Value>╭─┬─╮
│ │ │
├─┼─┤
│ │ │
╰─┴─╯</Value>
      </NoteProperty>
      <NoteProperty>
        <Name>LightShade</Name>
        <Value>░</Value>
      </NoteProperty>
      <NoteProperty>
        <Name>LightTripleDash</Name>
        <Value>┌┄┬┄┐
┆ │ ┆
├┄┼┄┤
┆ │ ┆
└┄┴┄┘
</Value>
      </NoteProperty>
      <NoteProperty>
        <Name>MediumShade</Name>
        <Value>▒</Value>
      </NoteProperty>
      <NoteProperty>
        <Name>PipeDash</Name>
        <Value>|-|</Value>
      </NoteProperty>
      <NoteProperty>
        <Name>Solid</Name>
        <Value>█</Value>
      </NoteProperty>
      <NoteProperty>
        <Name>Star</Name>
        <Value>*</Value>
      </NoteProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.Input</Name>
    <Members>
      <AliasProperty>
        <Name>After</Name>
        <ReferencedMemberName>Append</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Before</Name>
        <ReferencedMemberName>Prepend</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Undo</Name>
        <ReferencedMemberName>Pop</ReferencedMemberName>
      </AliasProperty>
      <ScriptMethod>
        <Name>Append</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Appends content to a stackable function
.DESCRIPTION

#&gt;
param(
# The value to prepend.
$Value
)

$toAppend = if ($Value -is [ScriptBlock]) {
    $Value
} else {
    [ScriptBlock]::Create($this.Stringify($Value))
}

$currentFunction = $posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")[0]
$this.Current = {@(. $currentFunction; . $toAppend) -join ''}.GetNewClosure()
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Clear</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Clears a stackable function
.DESCRIPTION
    Clears a stackable function, resetting it to it's original state.
.EXAMPLE
    $Posh.Prompt.Clear()
#&gt;
if ($this.Stack -and $this.Stack.Count) {
    
    $posh.ExecutionContext.SessionState.psvariable.Set("function:$($this.FunctionName)", @($this.Stack.ToArray())[-1])     
    $this.Stack.Clear()
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Pop</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Pops the last value from a function stack
.DESCRIPTION
    Pops the latest value from a function stack, such as the prompt.
.EXAMPLE
    $Posh.Prompt.Pop()
#&gt;
param(
  
)

if ($this.Stack -and $this.Stack.Count) {
    $posh.ExecutionContext.SessionState.psvariable.Set("function:$($this.FunctionName)", $this.Stack.Pop()) 
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Prepend</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Prepends content to a stackable function.
.DESCRIPTION
    Prepends content to a stackable function.

    This takes the current entry and adds content to it's beginning.
#&gt;
param(
# The value to prepend.
$Value
)



$toPrepend = if ($Value -is [ScriptBlock]) {
    $Value
} else {
    [ScriptBlock]::Create($this.Stringify($Value))
}

$currentFunction = $posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")[0]
$this.Current = {@(. $toPrepend; . $currentFunction) -join ''}.GetNewClosure()
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Push</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Pushes an entry into a stackable function
.DESCRIPTION
    Pushes an entry into a stackable function.

    This overwrites the existing entry,
    and adds the previous value to the stack so it can be easily undone.
#&gt;
param(
# The new value for the function
[ScriptBlock]
$Value
)

$this.Current = $Value
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Replace</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Replaces content within a function
.DESCRIPTION
    Replaces content within a stackable function, such as the prompt.
.EXAMPLE
    # Replace both ends of the prompt
    $Posh.Prompt.Replace('PS ', 0x27d6,$true).Replace('&gt;', 0x27d5, $true)
.EXAMPLE
    $Posh.Prompt.Replace($(
        if ($env:User) {
            $env:User
        } elseif ($env:UserName) {
            $env:UserName
        }
    ),'***')
#&gt;
param(
# The content to replace
$Replace,

# The new value
$Value
)


$toReplace = if ($Value -is [ScriptBlock]) {
    $Value
} else {
    [ScriptBlock]::Create($this.Stringify($Value))
}

$currentFunction = $posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")[0]

$passThru = $false
foreach ($arg in $args) {
    if ($arg -is [bool] -and $arg) {
        $passThru = $true
    }
}
$newFunc = {
    @(
        $existingOutput =. $currentFunction
        $replaceRegex = [Regex]::new($Replace,'IgnoreCase,IgnorePatternWhitespace','00:00:02')
        $replaceRegex.Replace($existingOutput, $toReplace)
    ) -join ''
}.GetNewClosure()

$this.Current = $newFunc
if ($passThru) {
    $this
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Stringify</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Converts into a stringified value
.DESCRIPTION
    Converts an item into a stringified value.

    This is used internally by stackable functions when they are prepending or appending.
#&gt;
param(
$Prompt
)



if ($Prompt -is [ScriptBlock]) {
    ". {$prompt}"
} else {
    "'$(
        $(
    if ($Prompt -is [int]) {
        if ($Prompt -le 1000) {
            $Prompt -as [char] -as [string]
        } else {
            $ExecutionContext.SessionState.InvokeCommand.ExpandString('`u{'+("{0:x}" -f $Prompt)  + '}')
        }
    } else {
        $Prompt
    }
        ) -replace "'","''"
    )'"
}
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>Current</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the value of a stackable function
.DESCRIPTION
    Gets the current value of a stackable function.
.EXAMPLE
    $posh.Prompt.Current
#&gt;
$posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the current implementation of a function
.DESCRIPTION
    Sets the current imlementation of a stackable function.

    Stackable functions keep a stack of all prior entries for easy undo.
.EXAMPLE
    $Posh.Prompt.Current = {"?"}
#&gt;
if (-not $this.FunctionName) { return }
$currentFunctionValue = $posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")[0]
$this.Stack.Push(
$currentFunctionValue
)
$newFunctionValue = $args[0]
if ($newFunctionValue -isnot [ScriptBlock]) {
    $newFunctionValue = [ScriptBlock]::Create($this.Stringify($newFunctionValue))
}
$posh.ExecutionContext.SessionState.PSVariable.Set("function:$($this.FunctionName)", $newFunctionValue)
                    </SetScriptBlock>
      </ScriptProperty>
      <NoteProperty>
        <Name>README</Name>
        <Value>PowerShell has a robust input system.

There's a very useful module by the name of PSReadLine that helps handle advanced input.

Posh allows you to override the input function for PowerShell in a safe, stackable way.

Pipe `$posh.Input` into `Get-Member` to see what it can do.</Value>
      </NoteProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.NET</Name>
    <Members>
      <AliasProperty>
        <Name>Abstracts</Name>
        <ReferencedMemberName>Abstract</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Alias</Name>
        <ReferencedMemberName>TypeAccelerator</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Aliases</Name>
        <ReferencedMemberName>TypeAccelerator</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Assemblies</Name>
        <ReferencedMemberName>Assembly</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Attributes</Name>
        <ReferencedMemberName>Attribute</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Cmdlets</Name>
        <ReferencedMemberName>Cmdlet</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Delegates</Name>
        <ReferencedMemberName>Delegate</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Enums</Name>
        <ReferencedMemberName>Enum</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Exceptions</Name>
        <ReferencedMemberName>Exception</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>ExtensionTypes</Name>
        <ReferencedMemberName>ExtensionType</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Generics</Name>
        <ReferencedMemberName>Generic</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Interfaces</Name>
        <ReferencedMemberName>Interface</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>TypeAccelerators</Name>
        <ReferencedMemberName>TypeAccelerator</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Types</Name>
        <ReferencedMemberName>Type</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>ValueTypes</Name>
        <ReferencedMemberName>ValueType</ReferencedMemberName>
      </AliasProperty>
      <ScriptMethod>
        <Name>Refresh</Name>
        <Script>
                        foreach ($property in $this.psobject.properties) {
    if ($property -is [psnoteproperty] -and 
        $property.Name -match '^\.') {
        $property.Value = @()
    }
}
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>Abstract</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets abstract types.
.DESCRIPTION
    Gets currently loaded abstract types.
.EXAMPLE
    $posh.Net.Abstract
#&gt;
foreach ($type in $this.Type) {
    if ($type.Attributes -band 'Abstract' -and -not ($type.Attributes -band 'Sealed')) {
        $type
    }
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Assembly</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets loaded assemblies
.DESCRIPTION
    Gets the currently loaded assemblies.
.EXAMPLE
    $Posh.Net.Assembly
.EXAMPLE
    $Posh.Net.Assemblies
#&gt;
[AppDomain]::CurrentDomain.GetAssemblies()
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Attribute</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets attribute types
.DESCRIPTION
    Gets all currently loaded attribute types
.EXAMPLE
    $Posh.Net.Attribute
.EXAMPLE
    $Posh.Net.Attributes
#&gt;
foreach ($type in $this.Type) {
    if ($type.IsSubclassOf([Attribute])) {
        $type
    }
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Cmdlet</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets cmdlet types
.DESCRIPTION
    Gets .net types that are subclasses of Cmdlet.
.EXAMPLE
    $posh.Net.Cmdlet
.EXAMPLE
    $posh.Net.Cmdlets

#&gt;
foreach ($type in $this.Public) {
    if ($type.IsSubclassOf([Management.Automation.Cmdlet])) {
        $type
    }
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Delegate</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets delegates
.DESCRIPTION
    Gets all currently loaded delegates.
.EXAMPLE
    $Posh.Net.Delegate
.EXAMPLE
    $Posh.Net.Delegates
#&gt;
foreach ($type in $this.Public) {
    if ($type.IsSubclassOf([Delegate])) {
        $type
    }
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Enum</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets enumerated typed
.DESCRIPTION
    Gets all currently loaded enumerated types
.EXAMPLE
    $Posh.Net.Enum
.EXAMPLE
    $Posh.Net.Enums
#&gt;
foreach ($type in $this.Type) {
    if ($type.IsEnum) {
        $type
    }
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Exception</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets exception types
.DESCRIPTION
    Gets all currently loaded exception types
.EXAMPLE
    $Posh.Net.Exception
.EXAMPLE
    $Posh.Net.Exceptions
#&gt;
foreach ($type in $this.Type) {
    if ($type.IsSubclassOf([Exception])) {
        $type
    }
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>ExtensionType</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets .NET extension types
.DESCRIPTION
    Gets .NET Extension Types.
    
    These types define extension methods for LINQ.
#&gt;
:nextType foreach ($type in $this.Type) {
    foreach ($attr in $type.GetCustomAttributes($false)) {
        if ($attr -is [Runtime.CompilerServices.ExtensionAttribute]) {
            $type
            continue nextType
        }
    }
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Generic</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets generic types.
.DESCRIPTION
    Gets currently loaded generic types.
.EXAMPLE
    $Posh.Net.Generic
.EXAMPLE
    $Posh.Net.Generics
#&gt;
foreach ($type in $this.Type) {
    if ($type.IsGenericType) {
        $type
    }
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Interface</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets all interfaces
.DESCRIPTION
    Gets all currently loaded interfaces
#&gt;
foreach ($type in $this.Type) {
    if ($type.IsInterface) {
        $type
    }
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Primitive</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets primitive types
.DESCRIPTION
    Gets all primitive types.

    Primitive types are used to build all other types.
.EXAMPLE
    $Posh.Net.Primitive
#&gt;
foreach ($type in $this.Type) {
    if ($type.IsPrimitive) {
        $type
    }
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Private</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets private types
.DESCRIPTION
    Gets all currently loaded private types
.EXAMPLE
    $Posh.Net.Private
#&gt;
foreach ($type in $this.Type) {
    if ($type.IsNotPublic) {
        $type
    }
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Public</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets public types
.DESCRIPTION
    Gets all currently loaded public types.
.EXAMPLE
    $Posh.Net.Public
#&gt;
foreach ($type in $this.Type) {
    if ($type.IsPublic) {
        $type
    }
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Static</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets static types.
.DESCRIPTION
    Gets currently loaded static types.
.EXAMPLE
    $posh.Net.Abstract
#&gt;
foreach ($type in $this.Type) {
    if ($type.Attributes -band 'Abstract,Sealed') {
        $type
    }
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Type</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets loaded types
.DESCRIPTION
    Gets all currently loaded types.
.EXAMPLE
    $Posh.Net.Type
.EXAMPLE
    $Posh.Net.Types    
#&gt;
if (-not ($this.'.Types')) {
    $this | 
        Add-Member NoteProperty '.Types' -Force -Value @(
            foreach ($assembly in $this.Assembly) {
                try {
                    $assembly.GetTypes()
                } catch {
                    # An assembly can refuse to .GetTypes(), or otherwise have an exception
                    # we do not want this to worry anyone, so we catch the exception
                    $ex = $_
                    $error.RemoveAt(0) # and remove it from $error
                }
            }
        )
}

$this.'.Types'
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>TypeAccelerator</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets type accelerators
.DESCRIPTION
    Gets currently loaded type accelerators.
.EXAMPLE
    $posh.Net.TypeAccelerator
.EXAMPLE
    $Posh.Net.TypeAccelerators
.EXAMPLE
    $Posh.Net.Alias
.EXAMPLE
    $Posh.Net.Aliases
#&gt;

$accelerators = ([psobject].assembly.gettype("System.Management.Automation.TypeAccelerators")::Get)
$acceleratorOutput = [Ordered]@{PSTypeName='Posh.Type.Accelerator'}
foreach ($kv in $accelerators.GetEnumerator()) {
    if ($kv.Key -ne 'PSObject') {
        $acceleratorOutput[$kv.Key] = $kv.Value    
    }    
}
[PSCustomObject]$acceleratorOutput
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets type accelerators
.DESCRIPTION
    Sets type accelerators (aliases for types)
.EXAMPLE
    $posh.Net.TypeAccelerator = @{'t'=[type]}
.EXAMPLE
    $posh.Net.Alias = 't10', [type]
#&gt;
param()

$accelerators = [psobject].assembly.gettype("System.Management.Automation.TypeAccelerators")
$currentString = ''

$unrolledArgs = $args | . { process { $_ } }
foreach ($arg in $unrolledArgs) {    
    if ($arg -is [Collections.IDictionary]) {
        
        foreach ($kv in $arg.GetEnumerator()) {
            if ($kv.Value -as [type]) {
                $null = $accelerators::Add($kv.Key, $kv.Value)
            }
        }
    }
    elseif ($arg -is [string]) {
        
        $currentString = "$arg"
    }
    elseif ($arg -is [type] -and $currentString) {
        
        $null = $accelerators::Add($currentString, [type]$arg)
        $currentString = ''
    } else {
        
    }
}
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>ValueType</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets Value Types
.DESCRIPTION
    Gets currently loaded .NET value types
    
    (types that represent a single value)
.EXAMPLE
    $posh.Net.ValueType
.EXAMPLE
    $Posh.Net.ValueTypes
#&gt;
foreach ($type in $this.Type) {
    if ($type.IsValueType) {
        $type
    }
}
                    </GetScriptBlock>
      </ScriptProperty>
      <NoteProperty>
        <Name>README</Name>
        <Value>### What Is .NET?

.NET is a framework of tools for building almost anything you can imagine.

PowerShell is built on top of .NET, and makes it easy to interactively explore.

.NET is object-oriented and strongly typed.

### $Posh.NET

Posh makes .NET easier to explore.

For example, to see all primitive types, just run:

~~~PowerShell
$Posh.Net.Primitive
~~~

To see all attributes, use:

~~~PowerShell
$Posh.Net.Attribute
~~~

To see all possible exceptions, use:

~~~PowerShell
$Posh.Net.Exceptions
~~~

To see everything $Posh.Net makes easier, pipe it to `Get-Member`

~~~PowerShell
$Posh.Net | Get-Member
~~~

### .NET Types in PowerShell

You can reference any public .NET type in PowerShell by putting it within brackets:

~~~PowerShell
[int]
~~~

You can see if an object is a type using the -is operator:

~~~PowerShell
1 -is [int]
~~~

You can cast an object to a type by putting it before an expression:

~~~PowerShell
[int]"1"
~~~

If the object cannot be cast, you will get an exception.

To see if you can cast an object, use the -as operator

~~~PowerShell
"1" -as [int]
~~~</Value>
      </NoteProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.Parameters</Name>
    <Members>
      <ScriptMethod>
        <Name>Clear</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Clears default parameter values.
.DESCRIPTION
    Clears all default parameter values.
.EXAMPLE
    $posh.Parameters.Clear()
#&gt;
$global:PSDefaultParameterValues.Clear()
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Remove</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Removes parameter default values.
.DESCRIPTION
    Removes the default values for a command.
.EXAMPLE
    $Posh.Parameters.Remove("Out-Default")
#&gt;
param(
# The name of the command.
$Command,

# The command parameters.
# If this is a dictionary, each value will be used.
# Otherwise, this will be treated as the name of the parameter.
$Parameter
)

$DefaultValueKey =
    if ($command -is [Management.Automation.CommandInfo]) {
        if ($command.Source) {
            $command.Source
        } else {
            $command.Name
        }        
    }
    else {
        "$command"
    }

if ($Parameter -is [Collections.IDictionary]) {
    foreach ($parameterKeyValue in $Parameter.GetEnumerator()) {
        $null = $global:PSDefaultParameterValues.Remove("${defaultValueKey}:$($parameterKeyValue.Key)")
    }
} elseif ($Parameter) {
    $null = $global:PSDefaultParameterValues["${defaultValueKey}:$Parameter"] = $DefaultValue
} else {
    $toRemoveKeys = $global:PSDefaultParameterValues.Keys -like "${defaultValueKey}:*"
    foreach ($toRemove in $toRemoveKeys) {
        $null = $global:PSDefaultParameterValues.Remove($toRemove)
    }
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>SetDefault</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Sets parameter default values.
.DESCRIPTION
    Sets the default value for a parameter.
.EXAMPLE
    $Posh.Parameters.SetDefault("Out-Default", "OutVariable", 'LastOutput')
#&gt;
param(
# The name of the command.
$Command,

# The command parameters.
# If this is a dictionary, each value will be used.
# Otherwise, this will be treated as the name of the parameter.
$Parameter,

# The default value.
$DefaultValue
)

$DefaultValueKey =
    if ($command -is [Management.Automation.CommandInfo]) {
        if ($command.Source) {
            $command.Source
        } else {
            $command.Name
        }        
    }
    else {
        "$command"
    }

if ($Parameter -is [Collections.IDictionary]) {
    foreach ($parameterKeyValue in $Parameter.GetEnumerator()) {
        $global:PSDefaultParameterValues["${defaultValueKey}:$($parameterKeyValue.Key)"] = 
            $parameterKeyValue.Value
    }
} else {
    $global:PSDefaultParameterValues["${defaultValueKey}:$Parameter"] = $DefaultValue
}
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>Defaults</Name>
        <GetScriptBlock>
                        $defaultsByCommand = [Ordered]@{}
foreach ($key in $global:PSDefaultParameterValues.Keys) {
    $commandName, $parameterName = $key -split ':',2
    if (-not $defaultsByCommand[$commandName]) {
        $defaultsByCommand[$commandName] = [Ordered]@{}
    }
    $defaultsByCommand[$commandName][$parameterName] = $global:PSDefaultParameterValues[$key]
}
$defaultsByCommand
                    </GetScriptBlock>
        <SetScriptBlock>
                        $argArray = @(
    foreach ($arg in $args) {
        $arg
    }
)
$this.SetDefault.Invoke($argArray)

                    </SetScriptBlock>
      </ScriptProperty>
      <NoteProperty>
        <Name>README</Name>
        <Value>One of the strengths of PowerShell is how it treats parameters.

You can find metadata about any command's parameters.

You can also provide default values for any command's parameters.

`$Posh.Parameters` helps you Find PowerShell parameters and manage their default values.</Value>
      </NoteProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.Preset.Collection</Name>
    <Members>
      <ScriptMethod>
        <Name>Refresh</Name>
        <Script>
                        $this | Add-Member NoteProperty '.Cache' @() -Force
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>All</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets all items in an extension collection.
.DESCRIPTION
    Gets all items in a collection of extended commands.
#&gt;
if (-not $this.'.Cache') {
    if (-not $this.'.Module') { return @() }

    $findExtensionArgs  = @($this.'.Module') + @($this.'.Path')
    $allExtensionsFound = 
        @(:nextExtension 
            foreach ($foundExtension in 
                $posh.Commands.FindExtensions.Invoke($findExtensionArgs)
            ) 
            {
            if ($this.'.CommandType') {
                foreach ($typename in $this.'.CommandType') {
                    if ($foundExtension.pstypenames -contains $typename) {
                        $foundExtension
                        continue nextExtension
                    }
                }
            } else {
                $foundExtension
            }
            }
        )
    $this |
        Add-Member NoteProperty '.Cache' $allExtensionsFound -Force
}

return $this.'.Cache'
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>CommandType</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets an extension collection's CommandType
.DESCRIPTION
    Gets the extended CommandTypes(s) that are stored in an extension collection.

    CommandTypes can be defined in a module's manifest.
#&gt;
return $this.'.CommandType'
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets an extension collection's command type
.DESCRIPTION
    Sets the extended command types in an extension collection.
#&gt;
param(
# The path.  If this is empty all extended commands will be present in the collection
[string[]]
$CommandType
)

Add-Member -InputObject $this -MemberType NoteProperty -Name '.CommandType' -Value $CommandType -Force
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Count</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the extension count.
.DESCRIPTION
    Gets the count of all extensions in a collection.
#&gt;
$this.All.Length
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Module</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets an extension collection's module
.DESCRIPTION
    Gets the module that defines extended types in an extension collection.
#&gt;
return $this.'.Module'
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets an extension collection's module
.DESCRIPTION
    Sets the module that defines extended command types in an extension collection.
#&gt;
param(
# The module.
[Management.Automation.PSModuleInfo]
$Module
)

Add-Member -InputObject $this -MemberType NoteProperty -Name '.Module' -Value $module -Force
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Path</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets an extension collection's Path
.DESCRIPTION
    Gets the Path(s) that store extensions in an extension collection.        
#&gt;
return $this.'.Path'
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets an extension collection's path
.DESCRIPTION
    Sets the path that defines extended command types in an extension collection.
#&gt;
param(
# The path.  If this is empty, only extensions that are functions or aliases will be found.
[string[]]
$Path
)

Add-Member -InputObject $this -MemberType NoteProperty -Name '.Path' -Value $Path -Force
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Random</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a random extended command
.DESCRIPTION
    Gets a random extended command from an ExtensionCollection.
#&gt;
$this.All | Get-Random
                    </GetScriptBlock>
      </ScriptProperty>
      <NoteProperty>
        <Name>README</Name>
        <Value>## Posh Presets

Posh Presets provide a way to store and apply presets for a variable.

They are simply data files, where each key or property repesents a expression and it's value represents what it will be set to.

Preset files can be .psd1, .json, or .clixml.

To see what presets can do, use $Posh.Presets | Get-Member</Value>
      </NoteProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.Preset.Command</Name>
    <Members>
      <AliasProperty>
        <Name>Apply</Name>
        <ReferencedMemberName>Use</ReferencedMemberName>
      </AliasProperty>
      <ScriptMethod>
        <Name>Use</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Uses a preset
.DESCRIPTION
    Uses or applies a Posh preset.

    Posh presets will take the data in a *.preset.* file and apply it to a variable.    
#&gt;

$importedData = 
    switch -regex ($this.Source) {
        '\.psd1$' {
            $importedAsLocalizedData = Import-LocalizedData -BaseDirectory ($this.Source | Split-Path) -FileName ($this.Source | Split-Path -Leaf)            
            if ($importedAsLocalizedData) {
                $replacedContent = [IO.File]::ReadAllText($this.Source) -replace '\@\{', '[Ordered]@{'
                &amp; ([ScriptBlock]::Create($replacedContent))
            }
        }
        '\.json$' {
            Get-Content $this.Source -Raw | ConvertFrom-Json
        }
        '.\clixml' {
            Import-Clixml $this.Source
        }
    }


if ($importedData -is [Collections.IDictionary]) {
    $importedData = [PSCustomObject]$importedData
}

foreach ($importedProperty in $importedData.psobject.properties) {
    if ($importedProperty.Name -notmatch '^\$') { continue }
    
    $importedNameScript = [ScriptBlock]::Create($importedProperty.Name)
    $valueToImport = $importedProperty.Value
    if (-not $importedNameScript) { continue }
    
    $statements = $importedNameScript.Ast.EndBlock.Statements
    
    $currentValue = try { . $importedNameScript } catch {$null}     

    # If we are importing a dictionary value, try to set each value within the dictionary
    if ($valueToImport -is [Collections.IDictionary]) {        
        if ($currentValue -is [Collections.IDictionary]) {            
            foreach ($ToImport in $valueToImport.GetEnumerator()) {
                $currentValue[$ToImport.Key] = $ToImport.Value
            }
        }
    } elseif ($valueToImport.GetType -and (
        $valueToImport.GetType().IsPrimitive -or 
        $valueToImport.GetType() -in [string], [DateTime], [timespan] 
    )) {
        $global:ExecutionContext.SessionState.InvokeCommand.InvokeScript(        
            "$importedNameScript = $valueToImport"
        )
    } elseif ($currentValue -is [Collections.IDictionary]) {
        foreach ($ToImport in $valueToImport.psobject.properties) {
            $currentValue[$ToImport.Name] = $ToImport.Value
        }
    }   
}
                    </Script>
      </ScriptMethod>
    </Members>
  </Type>
  <Type>
    <Name>Posh.Profiles</Name>
    <Members>
      <ScriptMethod>
        <Name>Add</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Adds content to a profile
.DESCRIPTION
    Adds content to a PowerShell profile
#&gt;
param(
# The content to add to your profile.
[ScriptBlock]
$Content,

# Which profile should the content be added to?
# The default is the current user's current host.
[ValidateSet('AllUsersAllHosts','AllUsersCurrentHosts','CurrentUserAllHosts','CurrentUserCurrentHost')]
[string]
$WhichProfile = 'CurrentUserCurrentHost'
)

$profilePath = $PROFILE.$WhichProfile

$profileContent = 
    if (Test-Path $profilePath) {
        Get-Content -Raw $profilePath 
    } else {
        ''
    }

if ($profileContent -like "*$Content*") {
    return
}

$profileContent += [Environment]::NewLine
$profileContent += "$content"
$profileContent | Set-Content -Path $profilePath -PassThru



                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>ImportModule</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Imports a module in a profile
.DESCRIPTION
    Adds code to import a module in your profile.
    This will ensure the module is loaded whenever you're running PowerShell.
.EXAMPLE
    $Posh.Profile.ImportModule("Posh")
#&gt;
param(
# The name of the module to import.
[string]
$Module,

# Which profile should the content be added to?
# The default is the current user's current host.
[ValidateSet('AllUsersAllHosts','AllUsersCurrentHosts','CurrentUserAllHosts','CurrentUserCurrentHost')]
[string]
$WhichProfile = 'CurrentUserCurrentHost'
)


$AlreadyAdded = $this.Matches("Import-Module $Module", $WhichProfile)
if (-not $AlreadyAdded) {
    $this.Add(
        [scriptblock]::Create("Import-Module $module -Force$([Environment]::Newline)"),
        $WhichProfile
    )
}

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Matches</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Matches patterns within profiles
.DESCRIPTION
    Matches a pattern within profile files.
    
    All places the pattern is found will be returned.
.EXAMPLE
    $Posh.Profile.Matches("Posh")
#&gt;
param(
# The pattern to match.
[regex]
$Pattern,

# Which profile should the content be removed from?
# The default is the current user's current host.
[ValidateSet('AllUsersAllHosts','AllUsersCurrentHosts','CurrentUserAllHosts','CurrentUserCurrentHost')]
[string[]]
$WhichProfile = 'CurrentUserCurrentHost'
)

@(foreach ($prof in $WhichProfile) {
    if (Test-Path ($profile.$prof)) {
        $pattern.Matches((Get-Content -Raw ($profile.$prof)))
    } 
})
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>New</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Creates a new profile
.DESCRIPTION
    Creates a new profile, or returns an existing profile.
.EXAMPLE
    $Posh.Profile.New()
#&gt;
param(
# Which profile should be created?
# The default is the current user's current host.
[ValidateSet('AllUsersAllHosts','AllUsersCurrentHosts','CurrentUserAllHosts','CurrentUserCurrentHost')]
[string]
$WhichProfile = 'CurrentUserCurrentHost'
)

$profilePath = $PROFILE.$WhichProfile

if (Test-Path -LiteralPath $profilePath) {
    Get-Item -LiteralPath $profilePath
} else {
    New-Item -ItemType File -Path $profilePath -Force
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Remove</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Removes content from a profile
.DESCRIPTION
    Removes content from a PowerShell profile.
#&gt;
param(
# The content to remove.
# If the content is a regular expression pattern, any matches will be removed.
# Otherwise, any case-insensitive occurances of the string will be removed.
$Content,

# Which profile should the content be removed from?
# The default is the current user's current host.
[ValidateSet('AllUsersAllHosts','AllUsersCurrentHosts','CurrentUserAllHosts','CurrentUserCurrentHost')]
[string]
$WhichProfile = 'CurrentUserCurrentHost'
)

$this.Replace($Content, '', $WhichProfile)
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>RemoveModule</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Remove a module from a profile
.DESCRIPTION
    Remove code that imports a module in your profile.
.EXAMPLE
    $Posh.Profile.RemoveModule("Posh")
#&gt;
param(    
# The name of the module to no longer import.
[string]
$Module,    

# Which profile should the content be added to?
# The default is the current user's current host.
[ValidateSet('AllUsersAllHosts','AllUsersCurrentHosts','CurrentUserAllHosts','CurrentUserCurrentHost')]
[string]
$WhichProfile = 'CurrentUserCurrentHost'
)


$AlreadyAdded = $this.Matches("Import-Module $Module", $WhichProfile)
if ($AlreadyAdded) {
    $this.Remove("Import-Module $Module", $WhichProfile)
}

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Replace</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Replaces content in a profile
.DESCRIPTION
    Replaces content in a PowerShell profile.
#&gt;
param(
# The content to replace.
# If the content is a regular expression pattern, any matches will be replaced.
# Otherwise, any case-insensitive occurances of the string will be replaced.
$Content,

# The content to replace.
# If content replaced was a regular expression,
# this will be treated as a [Regular Expression substitution](https://learn.microsoft.com/en-us/dotnet/standard/base-types/substitutions-in-regular-expressions).
$Replacement = '',

# Which profile should the content be removed from?
# The default is the current user's current host.
[ValidateSet('AllUsersAllHosts','AllUsersCurrentHosts','CurrentUserAllHosts','CurrentUserCurrentHost')]
[string]
$WhichProfile = 'CurrentUserCurrentHost'
)

$profilePath = $PROFILE.$WhichProfile

$profileContent = 
    if (Test-Path $profilePath) {
        Get-Content -Raw $profilePath 
    } else {
        ''
    }

if ($Content -is [regex]) {
    $profileContent = $Content.Replace($profileContent, $Replacement)
} else {
    $Content = "$content"
    if ($Content) {
        $profileContent = 
            $profileContent.Replace(
                $content, $Replacement, [StringComparison]::OrdinalIgnoreCase
            )
    }
}

$profileContent | Set-Content -Path $profilePath -PassThru
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>Current</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the current Profile
.DESCRIPTION
    Gets the current PowerShell Profile
.EXAMPLE
    $posh.Profile.Current
#&gt;
"$profile"

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Directory</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the profile directory
.DESCRIPTION
    Gets the PowerShell profile's directory.
.NOTES
    The Profile Directory is a wonderful place to store data.
    ( It is almost always writeable )
.EXAMPLE
    $Profile.Directory
#&gt;
($profile | Split-Path) -as [IO.DirectoryInfo]
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>File</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the profile file
.DESCRIPTION
    Gets the profile file for the current user in the current host.
.EXAMPLE
    $Posh.Profile.File    
#&gt;
if (Test-Path "$profile") {
    Get-Item -LiteralPath "$profile"
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Files</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the profile files
.DESCRIPTION
    Gets the FileInfo objects for each profile that exists.
.EXAMPLE
    $posh.Profile.Files
#&gt;
foreach ($potentialPath in $profile.CurrentUserCurrentHost, $profile.CurrentUserAllHosts, $profile.AllUsersAllHosts, $profile.AllUsersCurrentHost) {
    if ([IO.File]::Exists($potentialPath)) {
        [IO.FileInfo]$potentialPath
    }
}
                    </GetScriptBlock>
      </ScriptProperty>
      <NoteProperty>
        <Name>README</Name>
        <Value>PowerShell has profiles!

Profiles run whenever PowerShell is loaded.

They're great if there's a module you want to always load, or a variable you always want defined.

To see how to manipulate PowerShell profiles with Posh, use $posh.Profiles | Get-Member</Value>
      </NoteProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.Prompt</Name>
    <Members>
      <AliasProperty>
        <Name>After</Name>
        <ReferencedMemberName>Append</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Before</Name>
        <ReferencedMemberName>Prepend</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Undo</Name>
        <ReferencedMemberName>Pop</ReferencedMemberName>
      </AliasProperty>
      <ScriptMethod>
        <Name>Append</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Appends content to a stackable function
.DESCRIPTION

#&gt;
param(
# The value to prepend.
$Value
)

$toAppend = if ($Value -is [ScriptBlock]) {
    $Value
} else {
    [ScriptBlock]::Create($this.Stringify($Value))
}

$currentFunction = $posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")[0]
$this.Current = {@(. $currentFunction; . $toAppend) -join ''}.GetNewClosure()
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Clear</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Clears a stackable function
.DESCRIPTION
    Clears a stackable function, resetting it to it's original state.
.EXAMPLE
    $Posh.Prompt.Clear()
#&gt;
if ($this.Stack -and $this.Stack.Count) {
    
    $posh.ExecutionContext.SessionState.psvariable.Set("function:$($this.FunctionName)", @($this.Stack.ToArray())[-1])     
    $this.Stack.Clear()
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Pop</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Pops the last value from a function stack
.DESCRIPTION
    Pops the latest value from a function stack, such as the prompt.
.EXAMPLE
    $Posh.Prompt.Pop()
#&gt;
param(
  
)

if ($this.Stack -and $this.Stack.Count) {
    $posh.ExecutionContext.SessionState.psvariable.Set("function:$($this.FunctionName)", $this.Stack.Pop()) 
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Prepend</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Prepends content to a stackable function.
.DESCRIPTION
    Prepends content to a stackable function.

    This takes the current entry and adds content to it's beginning.
#&gt;
param(
# The value to prepend.
$Value
)



$toPrepend = if ($Value -is [ScriptBlock]) {
    $Value
} else {
    [ScriptBlock]::Create($this.Stringify($Value))
}

$currentFunction = $posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")[0]
$this.Current = {@(. $toPrepend; . $currentFunction) -join ''}.GetNewClosure()
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Push</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Pushes an entry into a stackable function
.DESCRIPTION
    Pushes an entry into a stackable function.

    This overwrites the existing entry,
    and adds the previous value to the stack so it can be easily undone.
#&gt;
param(
# The new value for the function
[ScriptBlock]
$Value
)

$this.Current = $Value
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Replace</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Replaces content within a function
.DESCRIPTION
    Replaces content within a stackable function, such as the prompt.
.EXAMPLE
    # Replace both ends of the prompt
    $Posh.Prompt.Replace('PS ', 0x27d6,$true).Replace('&gt;', 0x27d5, $true)
.EXAMPLE
    $Posh.Prompt.Replace($(
        if ($env:User) {
            $env:User
        } elseif ($env:UserName) {
            $env:UserName
        }
    ),'***')
#&gt;
param(
# The content to replace
$Replace,

# The new value
$Value
)


$toReplace = if ($Value -is [ScriptBlock]) {
    $Value
} else {
    [ScriptBlock]::Create($this.Stringify($Value))
}

$currentFunction = $posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")[0]

$passThru = $false
foreach ($arg in $args) {
    if ($arg -is [bool] -and $arg) {
        $passThru = $true
    }
}
$newFunc = {
    @(
        $existingOutput =. $currentFunction
        $replaceRegex = [Regex]::new($Replace,'IgnoreCase,IgnorePatternWhitespace','00:00:02')
        $replaceRegex.Replace($existingOutput, $toReplace)
    ) -join ''
}.GetNewClosure()

$this.Current = $newFunc
if ($passThru) {
    $this
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Stringify</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Converts into a stringified value
.DESCRIPTION
    Converts an item into a stringified value.

    This is used internally by stackable functions when they are prepending or appending.
#&gt;
param(
$Prompt
)



if ($Prompt -is [ScriptBlock]) {
    ". {$prompt}"
} else {
    "'$(
        $(
    if ($Prompt -is [int]) {
        if ($Prompt -le 1000) {
            $Prompt -as [char] -as [string]
        } else {
            $ExecutionContext.SessionState.InvokeCommand.ExpandString('`u{'+("{0:x}" -f $Prompt)  + '}')
        }
    } else {
        $Prompt
    }
        ) -replace "'","''"
    )'"
}
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>Current</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the value of a stackable function
.DESCRIPTION
    Gets the current value of a stackable function.
.EXAMPLE
    $posh.Prompt.Current
#&gt;
$posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the current implementation of a function
.DESCRIPTION
    Sets the current imlementation of a stackable function.

    Stackable functions keep a stack of all prior entries for easy undo.
.EXAMPLE
    $Posh.Prompt.Current = {"?"}
#&gt;
if (-not $this.FunctionName) { return }
$currentFunctionValue = $posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")[0]
$this.Stack.Push(
$currentFunctionValue
)
$newFunctionValue = $args[0]
if ($newFunctionValue -isnot [ScriptBlock]) {
    $newFunctionValue = [ScriptBlock]::Create($this.Stringify($newFunctionValue))
}
$posh.ExecutionContext.SessionState.PSVariable.Set("function:$($this.FunctionName)", $newFunctionValue)
                    </SetScriptBlock>
      </ScriptProperty>
      <NoteProperty>
        <Name>README</Name>
        <Value>`prompt` is the function that is called before PowerShell prompts for input.

$Posh.Prompt allows you to customize the PowerShell prompt.

Prompts are a cool way to customize your shell.

Pipe $Posh.Prompt to Get-Member to see what it can do.</Value>
      </NoteProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.Recommendation</Name>
    <Members>
      <AliasProperty>
        <Name>Update</Name>
        <ReferencedMemberName>Install</ReferencedMemberName>
      </AliasProperty>
      <ScriptMethod>
        <Name>Install</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Installs the recommended module
.DESCRIPTION
    Uses Install-Module to install the recommended module.
#&gt;
param(

)

if ($this.Name -and -not $this.Url) {    
    Install-Module $this.Name -Scope CurrentUser -Force
}


                    </Script>
      </ScriptMethod>
    </Members>
  </Type>
  <Type>
    <Name>Posh.RSS.Article</Name>
    <Members>
      <AliasProperty>
        <Name>Url</Name>
        <ReferencedMemberName>Link</ReferencedMemberName>
      </AliasProperty>
      <ScriptProperty>
        <Name>DatePublished</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets an article's date published
.DESCRIPTION
    Gets the date an article was published, as a `[DateTime]`.
.EXAMPLE
    $Posh.News.Article.DatePublished
#&gt;
$pubDateTime = $this.pubDate -as [DateTime]

if ($pubDateTime) {
    $pubDateTime
}
else {
    [datetime]::MinValue
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Name</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets an article's name
.DESCRIPTION
    Gets the name of an article in an RSS feed.
#&gt;
if ($this.Title -and $this.Title -isnot [string]) {
    if ($this.Title.InnerText) {
        $this.Title.InnerText
    } elseif ($this.Title -is [object[]]) {
        $this.Title | Select-Object -Unique -First 1
    }    
} elseif ($this.Title) {
    $this.Title
} elseif ($this.URL) {
    $thisURI = $this.URL -as [uri]
    $thisURI.Segments[-1] -replace '-', ' '
}
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.RSS.Feed</Name>
    <Members>
      <AliasProperty>
        <Name>Articles</Name>
        <ReferencedMemberName>Article</ReferencedMemberName>
      </AliasProperty>
      <ScriptProperty>
        <Name>Article</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets articles in a feed.
.DESCRIPTION
    Gets the articles in a RSS feed.

    Articles will be cached for performance.
.EXAMPLE
    $Posh.News.Article # Get all articles from all feeds associated with Posh.
#&gt;
if (-not $this.'.Article') {    
    Write-Progress "Getting Feeds" $this.Url 
    Add-Member -InputObject $this -MemberType NoteProperty -Name '.Article' -Value @(
        foreach ($feedItem in Invoke-RestMethod -Uri $this.Url) {
            $feedItem.pstypenames.insert(0,'Posh.RSS.Article')
            $feedItem | 
                Add-Member NoteProperty Source $this.Name -Force -PassThru
        }        
    ) -Force    
}
$this.'.Article'
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Recent</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets recent articles
.DESCRIPTION
    Gets recent articles in an RSS feed.
#&gt;
$after = $this.Source.News.RecentDuration
if (-not $after) {
    return       
}

foreach ($article in $this.Article) {    
    if (([DateTime]::Now - $article.DatePublished) -gt $after) {
        continue
    }
    $article
}
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.RSS.FeedCollection</Name>
    <Members>
      <AliasProperty>
        <Name>ByName</Name>
        <ReferencedMemberName>Feed</ReferencedMemberName>
      </AliasProperty>
      <ScriptProperty>
        <Name>Feed</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets feeds by name
.DESCRIPTION
    Gets all feeds in a collection by name.
#&gt;
param()
$this.All | Group-Object Name -AsHashTable
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Random</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a random feed
.DESCRIPTION
    Gets a random feed from a feed collection
#&gt;
$this.All | Get-Random
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Recent</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets all recent articles
.DESCRIPTION
    Gets all recent articles in a feed collection, sorted by date published.
.NOTES
    How "Recent" is defined in the a feed collection's `.RecentDuration` property.
#&gt;
@(foreach ($feed in $this.All) {
    $feed.Recent
}) | Sort-Object DatePublished -Descending
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>RecentDuration</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the duration considered recent
.DESCRIPTION
    Gets the duration that is used to determine how recent an article is.

    By default, this is 45 days.    
#&gt;
if (-not $this.'.RecentDuration') {
    $this | 
        Add-Member NoteProperty '.RecentDuration' (New-TimeSpan -Days 45) -Force
}

$this.'.RecentDuration'
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the duration considered recent
.DESCRIPTION
    Set the duration that is used to determine how recent an article is.
#&gt;
param(
[Timespan]
$RecentDuration
)

$this | 
    Add-Member NoteProperty '.RecentDuration' $RecentDuration -Force
                    </SetScriptBlock>
      </ScriptProperty>
      <NoteProperty>
        <Name>README</Name>
        <Value>Modules can put News in their module manifest.

Posh provides a simple RSS reader to help you stay up to date.

To view recent articles, use

~~~PowerShell
    $Posh.News.Recent
~~~

To view all feeds, use

~~~PowerShell
    $Posh.News.All
~~~

To view all articles from all feeds, use

~~~PowerShell
    $Posh.News.All.Article
~~~

To see a specific feed, use:

~~~PowerShell
    $Posh.News.Feed["PowerShell Team"]
~~~
</Value>
      </NoteProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.Stackable</Name>
    <Members>
      <AliasProperty>
        <Name>After</Name>
        <ReferencedMemberName>Append</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Before</Name>
        <ReferencedMemberName>Prepend</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Undo</Name>
        <ReferencedMemberName>Pop</ReferencedMemberName>
      </AliasProperty>
      <ScriptMethod>
        <Name>Append</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Appends content to a stackable function
.DESCRIPTION

#&gt;
param(
# The value to prepend.
$Value
)

$toAppend = if ($Value -is [ScriptBlock]) {
    $Value
} else {
    [ScriptBlock]::Create($this.Stringify($Value))
}

$currentFunction = $posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")[0]
$this.Current = {@(. $currentFunction; . $toAppend) -join ''}.GetNewClosure()
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Clear</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Clears a stackable function
.DESCRIPTION
    Clears a stackable function, resetting it to it's original state.
.EXAMPLE
    $Posh.Prompt.Clear()
#&gt;
if ($this.Stack -and $this.Stack.Count) {
    
    $posh.ExecutionContext.SessionState.psvariable.Set("function:$($this.FunctionName)", @($this.Stack.ToArray())[-1])     
    $this.Stack.Clear()
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Pop</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Pops the last value from a function stack
.DESCRIPTION
    Pops the latest value from a function stack, such as the prompt.
.EXAMPLE
    $Posh.Prompt.Pop()
#&gt;
param(
  
)

if ($this.Stack -and $this.Stack.Count) {
    $posh.ExecutionContext.SessionState.psvariable.Set("function:$($this.FunctionName)", $this.Stack.Pop()) 
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Prepend</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Prepends content to a stackable function.
.DESCRIPTION
    Prepends content to a stackable function.

    This takes the current entry and adds content to it's beginning.
#&gt;
param(
# The value to prepend.
$Value
)



$toPrepend = if ($Value -is [ScriptBlock]) {
    $Value
} else {
    [ScriptBlock]::Create($this.Stringify($Value))
}

$currentFunction = $posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")[0]
$this.Current = {@(. $toPrepend; . $currentFunction) -join ''}.GetNewClosure()
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Push</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Pushes an entry into a stackable function
.DESCRIPTION
    Pushes an entry into a stackable function.

    This overwrites the existing entry,
    and adds the previous value to the stack so it can be easily undone.
#&gt;
param(
# The new value for the function
[ScriptBlock]
$Value
)

$this.Current = $Value
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Replace</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Replaces content within a function
.DESCRIPTION
    Replaces content within a stackable function, such as the prompt.
.EXAMPLE
    # Replace both ends of the prompt
    $Posh.Prompt.Replace('PS ', 0x27d6,$true).Replace('&gt;', 0x27d5, $true)
.EXAMPLE
    $Posh.Prompt.Replace($(
        if ($env:User) {
            $env:User
        } elseif ($env:UserName) {
            $env:UserName
        }
    ),'***')
#&gt;
param(
# The content to replace
$Replace,

# The new value
$Value
)


$toReplace = if ($Value -is [ScriptBlock]) {
    $Value
} else {
    [ScriptBlock]::Create($this.Stringify($Value))
}

$currentFunction = $posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")[0]

$passThru = $false
foreach ($arg in $args) {
    if ($arg -is [bool] -and $arg) {
        $passThru = $true
    }
}
$newFunc = {
    @(
        $existingOutput =. $currentFunction
        $replaceRegex = [Regex]::new($Replace,'IgnoreCase,IgnorePatternWhitespace','00:00:02')
        $replaceRegex.Replace($existingOutput, $toReplace)
    ) -join ''
}.GetNewClosure()

$this.Current = $newFunc
if ($passThru) {
    $this
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Stringify</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Converts into a stringified value
.DESCRIPTION
    Converts an item into a stringified value.

    This is used internally by stackable functions when they are prepending or appending.
#&gt;
param(
$Prompt
)



if ($Prompt -is [ScriptBlock]) {
    ". {$prompt}"
} else {
    "'$(
        $(
    if ($Prompt -is [int]) {
        if ($Prompt -le 1000) {
            $Prompt -as [char] -as [string]
        } else {
            $ExecutionContext.SessionState.InvokeCommand.ExpandString('`u{'+("{0:x}" -f $Prompt)  + '}')
        }
    } else {
        $Prompt
    }
        ) -replace "'","''"
    )'"
}
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>Current</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the value of a stackable function
.DESCRIPTION
    Gets the current value of a stackable function.
.EXAMPLE
    $posh.Prompt.Current
#&gt;
$posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the current implementation of a function
.DESCRIPTION
    Sets the current imlementation of a stackable function.

    Stackable functions keep a stack of all prior entries for easy undo.
.EXAMPLE
    $Posh.Prompt.Current = {"?"}
#&gt;
if (-not $this.FunctionName) { return }
$currentFunctionValue = $posh.ExecutionContext.SessionState.InvokeCommand.InvokeScript("`$function:$($this.FunctionName)")[0]
$this.Stack.Push(
$currentFunctionValue
)
$newFunctionValue = $args[0]
if ($newFunctionValue -isnot [ScriptBlock]) {
    $newFunctionValue = [ScriptBlock]::Create($this.Stringify($newFunctionValue))
}
$posh.ExecutionContext.SessionState.PSVariable.Set("function:$($this.FunctionName)", $newFunctionValue)
                    </SetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>Posh.Tip.Command</Name>
    <Members>
      <ScriptProperty>
        <Name>Content</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets Tip content
.DESCRIPTION
    Gets the content of a Tip file
#&gt;
switch -regex ($this.Source) {
    '\.psd1$' {
        (Import-LocalizedData -BaseDirectory ($this.Source | Split-Path) -FileName ($this.Source | Split-Path -Leaf)).Content
    }
    '\.json$' {
        (Get-Content $this.Source -Raw | ConvertFrom-Json).Content
    }
    '\.md$' {
        Show-Markdown -LiteralPath $this.Source        
    }
    '\.ps1$' {
        $showDemoCommand = $ExecutionContext.SessionState.InvokeCommand.GetCommand('Show-Demo', 'Function')
        if ($showDemoCommand) {            
            $this.ScriptBlock
        } else {
            Get-Content $this.Source -Raw
        }
    }
}
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>System.Management.Automation.PSEventArgs</Name>
    <Members>
      <AliasProperty>
        <Name>EventID</Name>
        <ReferencedMemberName>EventIdentifier</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>SourceID</Name>
        <ReferencedMemberName>SourceIdentifier</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Time</Name>
        <ReferencedMemberName>TimeGenerated</ReferencedMemberName>
      </AliasProperty>
    </Members>
  </Type>
  <Type>
    <Name>System.Management.Automation.PSModuleInfo</Name>
    <Members>
      <AliasProperty>
        <Name>Demos</Name>
        <ReferencedMemberName>Demo</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Discussions</Name>
        <ReferencedMemberName>Discussion</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Feed</Name>
        <ReferencedMemberName>News</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Issues</Name>
        <ReferencedMemberName>Issue</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Links</Name>
        <ReferencedMemberName>Link</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Presets</Name>
        <ReferencedMemberName>Preset</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Recommendations</Name>
        <ReferencedMemberName>Recommendation</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Resource</Name>
        <ReferencedMemberName>Link</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Resources</Name>
        <ReferencedMemberName>Link</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>RSS</Name>
        <ReferencedMemberName>News</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Screenshots</Name>
        <ReferencedMemberName>Screenshot</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Taglines</Name>
        <ReferencedMemberName>Tagline</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Tests</Name>
        <ReferencedMemberName>Test</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Tips</Name>
        <ReferencedMemberName>Tip</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Trick</Name>
        <ReferencedMemberName>Tip</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Tricks</Name>
        <ReferencedMemberName>Tip</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Videos</Name>
        <ReferencedMemberName>Video</ReferencedMemberName>
      </AliasProperty>
      <ScriptMethod>
        <Name>Dismount</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Dismounts a module as a drive
.DESCRIPTION
    Dismounts a module as a drive.
#&gt;
param(
# The name of the drive.  If not provided, this will be the module.
[ValidatePattern("^\w{2,}")]
[string]
$DriveName
)

if (-not $DriveName) {
    $DriveName = $this.Name
}


if ($DriveName) {
    Remove-PSDrive -Name $DriveName -Scope Global -Force
}

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>LinkList</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Returns a link list.
.DESCRIPTION
    Returns a list of links from one or more properties in a module's manifest.
.EXAMPLE
    $posh.LinkList(@(
        $this.PrivateData.Screenshot
        $this.PrivateData.Screenshots
        $this.PrivateData.PSData.Screenshot
        $this.PrivateData.PSData.Screenshots
    ), "Posh.Module.Screenshot")
#&gt;
param(
# One or more inputs to the list.
[PSObject[]]
$InputObject,

# The name of each item in the list.
[string]
$PSTypeName = 'Posh.Module.Link',

# The name of a collection.  
# If this is provided, a collection containing all items will be returned.
[string]
$CollectionTypeName
)

filter ToLink {
    if ($_ -is [string]) {
        [PSCustomObject]@{
            PSTypeName = $PSTypeName
            Url        = $_
            Source     = $this
        }
    } elseif ($_ -is [Collections.IDictionary]) {
        $_.GetEnumerator() | Sort-Object Key | . ToLink
    } elseif ($_ -is [Collections.DictionaryEntry]) {
        [PSCustomObject][Ordered]@{
            PSTypeName = $PSTypeName
            Name = $_.key
            Url = $_.Value
            Source = $this
        }
    }
}


if ($CollectionTypeName) {
    [PSCustomObject][Ordered]@{
        PSTypeName = $CollectionTypeName
        All = @($inputObject | . ToLink)
    }
} else {
    $inputObject | . ToLink
}


                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Mount</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Mounts a module as a drive
.DESCRIPTION
    Mounts a module as a drive with the FileSystem provider.
#&gt;
param(
# The name of the drive.  If not provided, this will be the module.
[string]
$DriveName,

# The root path.  If not provided, this will be the module's root.
[string]
$RootPath
)

if (-not $DriveName) {
    $DriveName = $this.Name
}

if (-not $RootPath) {
    $RootPath = $this | Split-Path
}

if ($DriveName -and $RootPath) {
    New-PSDrive -ErrorAction Ignore -Name $DriveName -Root $RootPath -PSProvider FileSystem -Scope Global
}

                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>Demo</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets module demos
.DESCRIPTION
    Gets demo files related to a module.
.EXAMPLE
    $Posh.Demos
.LINK
    https://github.com/StartAutomating/ShowDemo
#&gt;
$this |
    Split-Path |
    Get-ChildItem -Recurse -Filter *.demo.ps1 |
    Select-Object -Unique
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Discussion</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a module's discussions URL.
.DESCRIPTION
    Gets the discussions URL related to a module.
.NOTES
    The Module must set it's ProjectURI, and it must be on GitHub, or this will return nothing.
#&gt;
if ($this.ProjectURI.Host -eq 'github.com') {
    [PSCustomObject][Ordered]@{
        Name = "$($this.Name) Discussions"
        Url = "$($this.ProjectURI)/discussions"
        PSTypeName = 'Posh.Module.Link'
    }
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Issue</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a module's issue URL.
.DESCRIPTION
    Gets the issues URL related to a module.
.NOTES
    The Module must set it's ProjectURI, and it must be on GitHub, or this will return nothing.
#&gt;
if ($this.ProjectURI.Host -eq 'github.com') {
    [PSCustomObject][Ordered]@{
        Name = "$($this.Name) Issues"
        Url = "$($this.ProjectURI)/issues"
        PSTypeName = 'Posh.Module.Link'
    }
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Link</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets Module Links
.DESCRIPTION
    Lists hyperlinks from this module.
.EXAMPLE
    $posh.Links
#&gt;
$this.LinkList(@(
    $this.PrivateData.Link
    $this.PrivateData.Links
    $this.PrivateData.Resource
    $this.PrivateData.Resources
    $this.PrivateData.PSData.Link
    $this.PrivateData.PSData.Links
    $this.PrivateData.PSData.Resource
    $this.PrivateData.PSData.Resources
), "Posh.Module.Link")


                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Logo</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets Module Logos
.DESCRIPTION
    Lists logos for this module.
.EXAMPLE
    $posh.Logos
#&gt;
$this.LinkList(@(
    $this.PrivateData.Logo
    $this.PrivateData.Logos
    $this.PrivateData.PSData.Logo
    $this.PrivateData.PSData.Logos
    $this.PrivateData.PSData.IconURI
), "Posh.Module.Logo")


                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>ModuleProfile</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a Module's Profile
.DESCRIPTION
    Gets the profile file associated with the module.

    Any module can have a file within the same directory as $profile, named `$($this.Name).profile.ps1`.

    This file may be loaded when the module loads, or anytime thereafter.
#&gt;
if (-not $profile) { return ''}
($profile | 
    Split-Path | 
    Join-Path -ChildPath "$($this.Name).profile.ps1"
).ToString()
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>ModuleProfiles</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a Module's Profiles
.DESCRIPTION
    Gets the profile files associated with the module.

    Any module can have a file within the same directory any valid $profile location, named `$($this.Name).profile.ps1`.

    This file may be loaded when the module loads, or anytime thereafter.
#&gt;
if (-not $profile) { return @()}
,@(@($profile.psobject.properties | 
        Where-Object MemberType -EQ NoteProperty |
        Select-Object -ExpandProperty Value) -as [io.fileinfo[]] | 
        Split-Path | 
        Select-Object -Unique |
        Where-Object { $_ } | 
        Join-Path -ChildPath "$($this.Name).profile.ps1" |
        Where-Object { $_ | Test-Path } |
        ForEach-Object { $_.FullName })
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>News</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a Module's News
.DESCRIPTION
    Lists RSS NewsFeeds from this module
.EXAMPLE
    $posh.News
#&gt;

if (-not $this.'.News') {
    $this | 
        Add-Member NoteProperty '.News' @(
            $this.LinkList(@(
                $this.PrivateData.RSS
                $this.PrivateData.News
                $this.PrivateData.Feed
                $this.PrivateData.PSData.RSS
                $this.PrivateData.PSData.News
                $this.PrivateData.PSData.Feed
            ), "Posh.RSS.Feed", "Posh.RSS.FeedCollection") | 
                Add-Member NoteProperty Module $this -Force -PassThru
        ) -Force       
}

$this.'.News'
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Presentation</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets module presentations
.DESCRIPTION
    Gets PowerPoint presentations and templates located within a PowerShell module.
#&gt;
$this |
    Split-Path |
    Get-ChildItem -Recurse |
    Where-Object Extension -In '.pptx', '.potx','.ppt' |
    Select-Object -Unique
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Preset</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Get's a module's presets
.DESCRIPTION
    Gets presets from a module.

    Any module can contain `*.preset(s)` files, of the extensions:
    
    * .psd1
    * .json
    * .clixml

    The collection of presets can be accessed in a Module's .Preset(s) properties    
#&gt;
if (-not $this.'.Preset') {
    $PresetCollection =
        [PSCustomObject][Ordered]@{
            PSTypeName  = 'Posh.ExtensionCollection'
            Module      = $posh
            Path        = @(Get-Module | Split-Path) -as [string[]]
            CommandType = 'Posh.Preset.Command'
        }
    $PresetCollection.pstypenames.insert(0,'Posh.Preset.Collection')
    $this |
        Add-Member NoteProperty '.Preset' $PresetCollection -Force
}
$this.'.Preset'
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>README</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a Module's README
.DESCRIPTION
    Gets the content of README.md file located at the module root. 
#&gt;
if ($this.'.README') {
    return $this.'.README'
}

$readmeFileExists = $this | 
    Split-Path | 
    Get-ChildItem | 
    Where-Object Name -eq 'README.md'

if ($readmeFileExists) {    
    $this | 
        Add-Member NoteProperty '.README' -Force (Get-Content -Raw $readmeFileExists)
    
    return $this.'.README'
}
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Recommendation</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets Module Recommendations
.DESCRIPTION
    Lists other modules this module recommends.
.EXAMPLE    
    # $Posh.Recommends gets every loaded module's recommendations.
    $posh.Recommends
.EXAMPLE
    $posh.Recommendations
#&gt;
$module = $this

$this.LinkList(@(
    
    $module.PrivateData.Recommends
    $module.PrivateData.Recommend
    $module.PrivateData.Recommendation
    $module.PrivateData.Recommendations

    $module.PrivateData.PSData.Recommends
    $module.PrivateData.PSData.Recommend
    $module.PrivateData.PSData.Recommendation
    $module.PrivateData.PSData.Recommendations
), "Posh.Recommendation")



                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Screenshot</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets Module Screenshots
.DESCRIPTION
    Lists screenshots from this module.
.EXAMPLE
    $posh.Screenshots
#&gt;
$this.LinkList(@(
    $this.PrivateData.Screenshot
    $this.PrivateData.Screenshots
    $this.PrivateData.PSData.Screenshot
    $this.PrivateData.PSData.Screenshots
), "Posh.Module.Screenshot")


                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Tagline</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets module taglines    
.DESCRIPTION
    Gets module taglines.  A tagline is an alternate description often used for posts and articles.

    Modules can only have one description, but can have as many taglines as they want.
#&gt;
param()
@(
    $this.PrivateData.Tagline,
    $this.PrivateData.Taglines,
    $this.PrivateData.PSData.Tagline,
    $this.PrivateData.PSData.Taglines
) -ne $null | &amp; { process { $_ } }

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Test</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets module tests
.DESCRIPTION
    Gets Pester Tests located within a module.
#&gt;
$this |
    Split-Path |
    Get-ChildItem -Recurse -Filter *.tests.ps1 |
    Select-Object -Unique
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Tip</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Get's a module's tips
.DESCRIPTION
    Gets tips and tricks from a module.

    Any module can contain `*.tip(s)` or `*.trick(s)` files, of the extensions:

    * .md
    * .txt
    * .ps1
    * .psd1
    * .json
    * .clixml

    The collection of tips can be accessed in a Module's .Tip(s) or .Trick(s) properties
    
#&gt;
if (-not $this.'.Tip') {
    $tipCollection =
        [PSCustomObject][Ordered]@{
            PSTypeName  = 'Posh.ExtensionCollection'
            Module      = $posh
            Path        = $this.Path | Split-Path
            CommandType = 'Posh.Tip.Command'
        }

    $tipCollection.pstypenames.insert(0,'Posh.Tip.Collection')
    $this | Add-Member NoteProperty '.Tip' $tipCollection -Force
}
$this.'.Tip'
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Video</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets Module Videos
.DESCRIPTION
    Lists videos about this module.
.EXAMPLE
    $posh.Videos
#&gt;
$this.LinkList(@(
    $this.PrivateData.Video
    $this.PrivateData.Videos
    $this.PrivateData.PSData.Video
    $this.PrivateData.PSData.Videos
), "Posh.Module.Video")


                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>System.TimeZoneInfo</Name>
    <Members>
      <ScriptProperty>
        <Name>LocalTime</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the local time
.DESCRIPTION
    Gets the local time for a timezone.
.EXAMPLE
    Get-TimeZone -ListAvailable
.EXAMPLE
    Get-TimeZone | Select LocalTime
#&gt;
[DateTime]::UTCNow + $this.GetUtcOffset([DateTime]::UtcNow)
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
</Types>
