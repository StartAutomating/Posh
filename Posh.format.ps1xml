<?xml version="1.0" encoding="utf-16"?>
<!-- Generated with EZOut 2.0.1: Install-Module EZOut or https://github.com/StartAutomating/EZOut -->
<Configuration>
  <SelectionSets>
    <SelectionSet>
      <Name>FileSystemTypes</Name>
      <Types>
        <TypeName>System.IO.DirectoryInfo</TypeName>
        <TypeName>System.IO.FileInfo</TypeName>
      </Types>
    </SelectionSet>
  </SelectionSets>
  <Controls>
    <Control>
      <Name>FileSystemTypes-GroupingFormat</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <Frame>
                <LeftIndent>4</LeftIndent>
                <CustomItem>
                  <Text AssemblyName="System.Management.Automation" BaseName="FileSystemProviderStrings" ResourceId="DirectoryDisplayGrouping" />
                  <ExpressionBinding>
                    <ScriptBlock>
                                            $_.PSParentPath.Replace("Microsoft.PowerShell.Core\FileSystem::", "")                                                  
                                        </ScriptBlock>
                  </ExpressionBinding>
                  <NewLine />
                </CustomItem>
              </Frame>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>FileSystemTypes.TreeNode</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>$Branch,$trunk = '├──', '    '
if ($script:treeDepth) {
    [Environment]::Newline + ($trunk * $script:TreeDepth)+ $Branch
} else {
    $Branch
}
$script:TreeDepth++;</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>Name</PropertyName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        if (-not $_.EnumerateFiles) { return $false }
        foreach ($f in $_.EnumerateFiles()) {$f;break}
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        $_.EnumerateFiles()
    </ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>FileSystemTypes.TreeNode</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        if (-not $_.EnumerateDirectories) { return $false }
        foreach ($f in $_.EnumerateDirectories()) {$f;break}
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        foreach ($d in $_.EnumerateDirectories()) {
            if ($d.Attributes -band 'Hidden') { continue }
            $d
        }
    </ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>FileSystemTypes.TreeNode</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>$script:TreeDepth--;</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$null</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>Posh.Link</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>
    @(
    if ($_.Name -and $_.Url) {
        if ($psStyle.FormatHyperlink -and -not $env:GITHUB_WORKSPACE) {
            $psStyle.FormatHyperlink($_.Name, $_.Url)
        } else {
            "[$($_.Name)]($($_.Url))"
        }
    } elseif ($_.Url) {
        $uri = [uri]$_.Url
        if ($psStyle.FormatHyperlink -and -not $env:GITHUB_WORKSPACE) {
            $psStyle.FormatHyperlink($_.Url, $uri)
        } else {
            "[$($_.Url)]($($uri))"
        }        
    }    
    ) -join ''
</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>Posh.Link.Play</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>
    @(
    if ($_.enclosure.url -and 
        $psStyle.FormatHyperlink -and -not $env:GITHUB_WORKSPACE) {
            " $($psStyle.FormatHyperlink("▶", $_.enclosure.url)) "
    }
    ) -join ''
</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>Posh.Link.Line</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock> $_ </ScriptBlock>
                <CustomControlName>Posh.Link</CustomControlName>
              </ExpressionBinding>
              <NewLine />
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>Posh.Tip.Control</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>
        $showDemoCommand = $ExecutionContext.SessionState.InvokeCommand.GetCommand('Show-Demo', 'Function')
        if ($showDemoCommand -and $_.Content -is [scriptblock]) {
            Show-Demo -DemoScript $_.Content -AutoPlay | Out-Null
        } else {
            $_.Content
        }                
    </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>TypeInheritanceControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock> ' ' * 1 </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Formatting.Verbose') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> $_ </ScriptBlock>
                <CustomControlName>TypeNameControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> ' ' * 1 </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BaseType -and -not $_.IsValueType </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> 
        ':'
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.BaseType -and -not $_.IsValueType -and $_.BaseType -ne [Object] </ScriptBlock>
                </ItemSelectionCondition>
                <PropertyName>BaseType</PropertyName>
                <CustomControlName>TypeBase</CustomControlName>
              </ExpressionBinding>
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock> '=' * ($Host.UI.RawUI.BufferSize.Width - 1) </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>TypeBase</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock> '  *' </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.Cyan','Bold') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>$_ </ScriptBlock>
                <CustomControlName>TypeNameControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>TypeConstructorsControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
    if ($_ -is [Type]) {
        $_.GetConstructors('Instance,Public')
    } elseif ($_.Type -and $_.BindingFlags) {
        $_.Type.GetConstructors($_.BindingFlags)
    }
</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> 
        [Environment]::NewLine + ('#' * 3) + ' Constructors:'           
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
    if ($_ -is [Type]) {
        $_.GetConstructors('Instance,Public')
    } elseif ($_.Type -and $_.BindingFlags) {
        $_.Type.GetConstructors($_.BindingFlags)
    }
</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
    if ($_ -is [Type]) {
        $_.GetConstructors('Instance,Public')
    } elseif ($_.Type -and $_.BindingFlags) {
        $_.Type.GetConstructors($_.BindingFlags)
    }
</ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>TypeMethodControl</CustomControlName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>TypeEventControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> -not $script:DisplayingMember  </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> [Environment]::NewLine </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> '  * ' </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Formatting.Warning') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>Name</PropertyName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <Text>(</Text>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.EventHandlerType.GetMethod('Invoke') </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        $MethodParameters = @($_.EventHandlerType.GetMethod('Invoke').GetParameters())
        foreach ($n in 0..($MethodParameters.Count - 1)) {
            if (-not $MethodParameters[$n]) { continue }
            $o =[PSObject]::new($MethodParameters[$n])
            $o.psobject.properties.add([PSNoteProperty]::new('N', $N))
            $o
        }
    </ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>TypeMethodParameterControl</CustomControlName>
              </ExpressionBinding>
              <Text>)</Text>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>TypeEventsControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
    if ($_ -is [Type]) {
        $_.GetEvents('Instance,Public')
    } elseif ($_.Type -and $_.BindingFlags) {
        $_.Type.GetEvents($_.BindingFlags)
    }
</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> 
        [Environment]::NewLine + ('#' * 3) + ' Events:'
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
    if ($_ -is [Type]) {
        $_.GetEvents('Instance,Public')
    } elseif ($_.Type -and $_.BindingFlags) {
        $_.Type.GetEvents($_.BindingFlags)
    }
</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
    if ($_ -is [Type]) {
        $_.GetEvents('Instance,Public')
    } elseif ($_.Type -and $_.BindingFlags) {
        $_.Type.GetEvents($_.BindingFlags)
    }
</ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>TypeEventControl</CustomControlName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>TypeFieldControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> -not $script:DisplayingMember  </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> [Environment]::NewLine </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> '  * '</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.Cyan','Bold') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>FieldType</PropertyName>
                <CustomControlName>TypeNameControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Formatting.Warning') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>Name</PropertyName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>TypeInterfaceControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock> '  *' </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.Cyan','Bold') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>$_ </ScriptBlock>
                <CustomControlName>TypeNameControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>TypeMemberControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> 
        'RuntimeMethodInfo', 'RuntimeConstructorInfo' -contains $_.GetType().Name
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$_ </ScriptBlock>
                <CustomControlName>TypeMethodControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.GetType().Name -eq 'RuntimePropertyInfo' </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$_ </ScriptBlock>
                <CustomControlName>TypePropertyControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> 
        
        'MdFieldInfo', 'RtFieldInfo' -contains $_.GetType().Name 
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$_ </ScriptBlock>
                <CustomControlName>TypeFieldControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.GetType().Name -eq 'RuntimeEventInfo' </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$_ </ScriptBlock>
                <CustomControlName>TypeEventControl</CustomControlName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>TypeMethodControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> -not $script:DisplayingMember  </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> [Environment]::NewLine </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> '  *' </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.IsStatic </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> ' static ' </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>$_.IsConstructor </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.Cyan','Bold') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>$_.IsConstructor </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> $_.DeclaringType </ScriptBlock>
                <CustomControlName>TypeNameControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>$_.IsConstructor </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> -not $_.IsConstructor -and $_.ReturnType </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.Cyan','Bold') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> -not $_.IsConstructor -and $_.ReturnType </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> $_.ReturnType </ScriptBlock>
                <CustomControlName>TypeNameControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> -not $_.IsConstructor -and $_.ReturnType </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        @(if (-not $_.IsConstructor) {
            ' '
            if ($_.IsPublic) {
                if ($PSStyle) {
                    $PSStyle.Formatting.Warning
                }
            }
            elseif ($_.IsPrivate) {
                if ($PSStyle) {
                    $PSStyle.Formatting.Error
                }
            }
            else {
                if ($PSStyle) {
                    $PSStyle.Formatting.Warning
                }
            }
            
            $_.Name
            if ($PSStyle) {
                $PSStyle.Reset
            }
        }) -join ''
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> ' (' </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        $MethodParameters = @($_.GetParameters())
        foreach ($n in 0..($MethodParameters.Count - 1)) {
            if (-not $MethodParameters[$n]) { continue }
            $o =[PSObject]::new($MethodParameters[$n])
            $o.psobject.properties.add([PSNoteProperty]::new('N', $N))
            $o
        }
    </ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>TypeMethodParameterControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> ')' </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>TypeMethodParameterControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.N -gt 0</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> ', ' </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.Cyan','Bold') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>ParameterType</PropertyName>
                <CustomControlName>TypeNameControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>$_.Name </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Formatting.Warning') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>$_.Name </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> '$' + $_.Name + ' ' </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>$_.Name </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>TypeMethodsControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
    if ($_ -is [Type]) {
        $_.GetMethods('Static,Public')
    } elseif ($_.Type -and $_.BindingFlags) {
        $_.Type.GetMethods("Static,$($_.BindingFlags)")
    }
</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> 
        [Environment]::NewLine + ('#' * 3) + ' Static Methods:'           
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
    if ($_ -is [Type]) {
        $_.GetMethods('Static,Public')
    } elseif ($_.Type -and $_.BindingFlags) {
        $_.Type.GetMethods("Static,$($_.BindingFlags)")
    }
</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
    if ($_ -is [Type]) {
        $_.GetMethods('Static,Public')
    } elseif ($_.Type -and $_.BindingFlags) {
        $_.Type.GetMethods("Static,$($_.BindingFlags)")
    }
</ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>TypeMethodControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
    if ($_ -is [Type]) {
        $_.GetMethods('Instance,Public')
    } elseif ($_.Type -and $_.BindingFlags) {
        $_.Type.GetMethods("Instance,$($_.BindingFlags)")
    }
</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> 
        [Environment]::NewLine + ('#' * 3) + ' Methods:'           
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
    if ($_ -is [Type]) {
        $_.GetMethods('Instance,Public')
    } elseif ($_.Type -and $_.BindingFlags) {
        $_.Type.GetMethods("Instance,$($_.BindingFlags)")
    }
</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
    if ($_ -is [Type]) {
        $_.GetMethods('Instance,Public')
    } elseif ($_.Type -and $_.BindingFlags) {
        $_.Type.GetMethods("Instance,$($_.BindingFlags)")
    }
</ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>TypeMethodControl</CustomControlName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>TypeNameControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <Text> [</Text>
              <ExpressionBinding>
                <ScriptBlock>
        if ($_.FullName) {
            $_.Fullname -replace '`.+', '' -replace '^System\.', ''
        } else {
            $_.Name -replace '`.+', '' -replace '^System\.', ''
        }
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        $_.IsGenericType
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        $_.GenericTypeArguments
    </ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>TypeNameControl</CustomControlName>
              </ExpressionBinding>
              <Text>]</Text>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>TypePropertiesControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
    if ($_ -is [Type]) {
        $_.GetProperties('Static,Public')
    } elseif ($_.Type -and $_.BindingFlags) {
        $_.Type.GetProperties("Static,$($_.BindingFlags)")
    }
</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> 
        [Environment]::NewLine + ('#' * 3) + ' Static Properties:'           
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
    if ($_ -is [Type]) {
        $_.GetProperties('Static,Public')
    } elseif ($_.Type -and $_.BindingFlags) {
        $_.Type.GetProperties("Static,$($_.BindingFlags)")
    }
</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
    if ($_ -is [Type]) {
        $_.GetProperties('Static,Public')
    } elseif ($_.Type -and $_.BindingFlags) {
        $_.Type.GetProperties("Static,$($_.BindingFlags)")
    }
</ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>TypePropertyControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
    if ($_ -is [Type]) {
        $_.GetProperties('Instance,Public')
    } elseif ($_.Type -and $_.BindingFlags) {
        $_.Type.GetProperties("Instance,$($_.BindingFlags)")
    }
</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> 
        [Environment]::NewLine + ('#' * 3) + ' Properties:'           
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
    if ($_ -is [Type]) {
        $_.GetProperties('Instance,Public')
    } elseif ($_.Type -and $_.BindingFlags) {
        $_.Type.GetProperties("Instance,$($_.BindingFlags)")
    }
</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
    if ($_ -is [Type]) {
        $_.GetProperties('Instance,Public')
    } elseif ($_.Type -and $_.BindingFlags) {
        $_.Type.GetProperties("Instance,$($_.BindingFlags)")
    }
</ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>TypePropertyControl</CustomControlName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>TypePropertyControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> -not $script:DisplayingMember  </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> [Environment]::NewLine </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> '  * '</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.Cyan','Bold') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>PropertyType</PropertyName>
                <CustomControlName>TypeNameControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Formatting.Warning') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>Name</PropertyName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        ' {' +
        $(if ($_.CanRead) {'get;'}) +
        $(if ($_.CanWrite) {'set;'})+
        '}'
    </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>XmlNodeControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>$Branch,$trunk = '', '    '
if ($script:treeDepth) {
    [Environment]::Newline + ($trunk * $script:TreeDepth)+ $Branch
} else {
    $Branch
}
$script:TreeDepth++;</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>'#text','#whitespace','#comment','#document' -notcontains $_.LocalName </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.BrightBlack') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>'#text','#whitespace','#comment','#document' -notcontains $_.LocalName </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> '&lt;'.Trim() </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>'#text','#whitespace','#comment','#document' -notcontains $_.LocalName </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>'#text','#whitespace','#comment','#document' -notcontains $_.LocalName </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.BrightBlue','Bold') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>'#text','#whitespace','#comment','#document' -notcontains $_.LocalName </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        $_.LocalName
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>'#text','#whitespace','#comment','#document' -notcontains $_.LocalName </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        $_.HasAttributes -and '#text', '#whitespace' -notcontains $_.LocalName
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$_.Attributes</ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>XmlAttributeControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>'#text','#whitespace','#comment','#document' -notcontains $_.LocalName </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.BrightBlack') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>'#text','#whitespace','#comment','#document' -notcontains $_.LocalName </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        if ($_.HasChildren -or $_.HasChildNodes) {
            '&gt;'
        } else {
            '/&gt;'
        }
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>'#text','#whitespace','#comment','#document' -notcontains $_.LocalName </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.LocalName -in '#text' </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.Green') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.LocalName -in '#text' </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$_.InnerText </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.LocalName -in '#text' </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.LocalName -in '#comment' </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.BrightGreen') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.LocalName -in '#comment' </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> "&lt;!--$($_.InnerText)--&gt;" + [Environment]::NewLine </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.LocalName -in '#comment' </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.HasChildren -or $_.HasChildNodes -and $_.LocalName -ne '#whitespace'</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
    @(foreach ($cn in $_.ChildNodes) {
        if ($cn.LocalName -eq '#whitespace') { continue }
        $cn
    })
</ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>XmlNodeControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.BrightBlack') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        if (-not ($_.HasChildren -or $_.HasChildNodes)) {
            ''
        } else {
            [Environment]::NewLine + (' ' * ($script:TreeDepth - 1)* 4) + '&lt;/'
        }
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.BrightBlue','Bold') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
         if ($_.HasChildren -or $_.HasChildNodes) { $_.LocalName}
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.BrightBlack') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
         if ($_.HasChildren -or $_.HasChildNodes) {'&gt;'}
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>$script:TreeDepth--;</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$null</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>XmlAttributeControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock> ' ' </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.BrightCyan') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        $_.Name
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.BrightBlack') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        $null = $_.OuterXml -match '=\s{0,}(?&lt;q&gt;["''])'
        if ($matches.Q) {
            '=' + $matches.Q
        }
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.Magenta') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        [security.SecurityElement]::Escape($_.Value)
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.BrightBlack') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        $null = $_.OuterXml -match '=\s{0,}(?&lt;q&gt;["''])'
        $matches.Q
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>ProcessGroupControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'Posh'

            do {
                $lm = Get-Module -Name $moduleName -ErrorAction Ignore
                if (-not $lm) { continue } 
                if ($lm.FormatPartsLoaded) { break }
                $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
                    foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
                        $ParentNode = $partNodeName.Node.ParentNode
                        "$($ParentNode.Name)={
            $($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
                    }
                }) -join [Environment]::NewLine
                New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
                    Import-Module -Global
                $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
                
                if (-not $lm.OnRemove) {
                    $lm.OnRemove = $onRemove
                } else {
                    $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
                }
                $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force
            
            } while ($false)
            
        

        . ${Posh_Indent} $_.ProcessName
    </ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock>
        . ${Posh_Indent} $_.Path
    </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>VersionControl</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>
        if ($PSStyle) {
            @(foreach ($versionPart in $_.ToString() -split "\.") {
                @(
                    $PSStyle.Foreground.Cyan
                    $PSStyle.Bold
                    $versionPart
                    $PSStyle.Reset
                ) -join ''            
            }) -join "$(
                @(
                    $PSStyle.Foreground.Blue
                    '.'
                ) -join ''      
            )"
        } else {
            $_.ToString()
        }
    </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>${Posh_Indent}</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>&lt;#
.Synopsis
    Indents content
.Description
    Indents content.

    In most scenarios, content is indented by a number of spaces

    If $request or $host.UI.SupportsHTML, this will render a div tag with margin-left set to $Length ex 
    (this is the equivilent of N characters of indentation in HTML)
.Notes
    IsFormatPart: true
#&gt;
param(
$Content,

[ValidateRange(0,100)]
[Alias('Spaces')]
[uint32]
$Length = 4
)

if ($Request -or $Host.UI.SupportsHTML) {
    return "&lt;div style='margin-left:${Length}ex'&gt;$content&lt;/div&gt;"
}

(' ' * $Length) + "$content"</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>${Posh_Format-Yaml}</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>
    &lt;#
    .SYNOPSIS
        Formats objects as YAML
    .DESCRIPTION
        Formats an object as YAML.
    .EXAMPLE
        Format-Yaml -InputObject @("a", "b", "c")
    .EXAMPLE
        @{a="b";c="d";e=@{f=@('g')}} | Format-Yaml
    #&gt;
    [Management.Automation.Cmdlet("Format","Object")]
    [ValidateScript({return $true})]
    param(
    # The InputObject.
    [Parameter(ValueFromPipeline)]
    [PSObject]
    $InputObject,

    # If set, will make a YAML header by adding a YAML Document tag above and below output.
    [Alias('YAMLDocument')]
    [switch]
    $YamlHeader,

    [int]
    $Indent = 0,

    # The maximum depth of objects to include.
    # Beyond this depth, an empty string will be returned.    
    [int]
    $Depth
    )

    begin {
        if (-not $Depth) { $depth = $FormatEnumerationLimit }
        $toYaml = {
            param(
            [Parameter(ValueFromPipeline,Position=0)]$Object,
            [Object]$Parent,
            [Object]$GrandParent,
            [int]$Indent = 0)
            
            begin { $n = 0; $mySelf = $myInvocation.MyCommand.ScriptBlock }
            process {
                $n++
                if ($Object -eq $null) { return }

                if ($depth) {
                    $myDepth = $indent / 2
                    if ($myDepth -gt $depth) {
                        return ''
                    }
                }
            
                if ($Parent -and $Parent -is [Collections.IList]) {
                    if ($Parent.IndexOf($Object) -gt 0) { ' ' * $Indent }
                    '- '
                }
            
                #region Primitives
                if ( $Object -is [string] ) { # If it's a string
                    if ($object -match '\n') { # see if it's a multline string.
                        "|" # If it is, emit the multiline indicator
                        $indent +=2
                        foreach ($l in $object -split '(?&gt;\r\n|\n)') { # and emit each line indented
                            [Environment]::NewLine
                            ' ' * $indent
                            $l
                        }
                        $indent -=2
                    } elseif ("$object".Contains('*')) {
                        "'$($Object -replace "'","''")'"
                    } else {
                        $object
                    }
            
                    if ($Parent -is [Collections.IList]) { # If the parent object was a list
                        [Environment]::NewLine # emit a newline.
                    }
                    return # Once the string has been emitted, return.
                }
                if ( $Object.GetType().IsPrimitive ) { # If it is a primitive type
                    "$Object".ToLower()  # Emit it in lowercase.
                    if ($Parent -is [Collections.IList]) {
                        [Environment]::NewLine
                    }
                    return
                }
                #endregion Primitives
            
                #region KVP
                if ( $Object -is [Collections.DictionaryEntry] -or $object -is [Management.Automation.PSPropertyInfo]) {
                    if ($Parent -isnot [Collections.IList] -and
                        ($GrandParent -isnot [Collections.IList] -or $n -gt 1)) {
                        [Environment]::NewLine + (" " * $Indent)
                    }
                    if ($object.Key -and $Object.Key -is [string]) {
                        $Object.Key +": "
                    } elseif ($object.Name -and $object.Name -is [string]) {
                        $Object.Name +": "
                    }
                }
            
                if ( $Object -is [Collections.DictionaryEntry] -or $Object -is [Management.Automation.PSPropertyInfo]) {
                    &amp; $mySelf -Object $Object.Value -Parent $Object -GrandParent $parent -Indent $Indent
                    return
                }
                #endregion KVP
            
            
                #region Nested
                if ($parent -and ($Object -is [Collections.IDictionary] -or $Object  -is [PSObject])) {
                    $Indent += 2
                } 
                elseif ($object -is [Collections.IList]) {
                    $allPrimitive = 1
                    foreach ($Obj in $Object) { 
                        $allPrimitive = $allPrimitive -band (
                            $Obj -is [string] -or 
                            $obj.GetType().IsPrimitive
                        ) 
                    }
                    if ($parent -and -not $allPrimitive) {
                        $Indent += 2
                    }
                }
            
            
                if ( $Object -is [Collections.IDictionary] ) {
                    $Object.GetEnumerator() |
                        &amp; $mySelf -Parent $Object -GrandParent $Parent -Indent $Indent
                } elseif ($Object -is [Collections.IList]) {
            
                    [Environment]::NewLine + (' ' * $Indent)
            
                    $Object |
                        &amp; $mySelf -Parent $Object -GrandParent $Parent -Indent $Indent
            
                } 
                elseif ($object -is [enum]) {
                    $object.ToString()
                }
                elseif ($Object.PSObject.Properties) {
                    $Object.psobject.properties |
                        &amp; $mySelf -Parent $Object -GrandParent $Parent -Indent $Indent
                }
            
                if ($Object -is [Collections.IDictionary] -or $Object  -is [PSCustomObject] -or $Object -is [Collections.IList]) {
                    if ($Parent -is [Collections.IList]) { [Environment]::NewLine }
                    $Indent -= 2;
                }
                #endregion Nested
            }                
        }
        function IndentString([string]$String,[int]$Indent) {
            @(foreach ($line in @($String -split '(?&gt;\r\n|\n)')) {
                (' ' * $indent) + $line 
            }) -join [Environment]::NewLine
        }
        $inputWasNotPiped = $PSBoundParameters.InputObject -as [bool]
        $allInputObjects  = @()
    }

    process {
        if ($inputWasNotPiped) {
            IndentString ('' + $(if ($YamlHeader) { '---' + [Environment]::NewLine })  + (
                (&amp; $toYaml -object $inputObject) -join '' -replace 
                    "$([Environment]::NewLine * 2)", [Environment]::NewLine
            ) + $(if ($YamlHeader) { [Environment]::NewLine  + '---'})) -Indent $Indent
        } else {
            $allInputObjects += $inputObject
        }
    }

    end {
        if (-not $allInputObjects) { return }
        if ($allInputObjects.Length -eq 1) {
            IndentString ('' + $(if ($YamlHeader) { '---' + [Environment]::NewLine}) + (
                (&amp; $toYaml -object $inputObject) -join '' -replace 
                    "$([Environment]::NewLine * 2)", [Environment]::NewLine
            ) + $(if ($YamlHeader) { [Environment]::NewLine  + '---'})) -Indent $Indent
        } else {
            IndentString ('' + $(if ($YamlHeader) { '---' + [Environment]::NewLine})  + (
                (&amp; $toYaml -object $allInputObjects) -join '' -replace 
                    "$([Environment]::NewLine * 2)", [Environment]::NewLine
            ) + $(if ($YamlHeader) { [Environment]::NewLine  + '---'})) -Indent $Indent
        }
    }
</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>${Posh_Format-Markdown}</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>
    &lt;#
    .SYNOPSIS
        Formats an object as Markdown
    .DESCRIPTION
        Formats an object as Markdown, with many options to work with
    .EXAMPLE
        Format-Markdown -ScriptBlock {
            Get-Process
        }
    .EXAMPLE
         1..6 | Format-Markdown  -HeadingSize { $_ }
    #&gt;
    [Management.Automation.Cmdlet("Format","Object")]
    [ValidateScript({return $true})]
    param(            
    [Parameter(ValueFromPipeline,ValueFromPipelineByPropertyName)]
    [PSObject]
    $InputObject,
    
    # If set, will treat the -InputObject as a paragraph.
    # This is the default for strings, booleans, numbers, and other primitive types.
    [Parameter(ValueFromPipelineByPropertyName)]
    [switch]
    $MarkdownParagraph,

    # If set, will generate a markdown table.
    [Parameter(ValueFromPipelineByPropertyName)]
    [switch]
    $MarkdownTable,

    # If provided, will align columnns in a markdown table.    
    [Parameter(ValueFromPipelineByPropertyName)]
    [ValidateSet("Left","Right","Center", "")]
    [string[]]
    $MarkdownTableAlignment,

    # An array of properties.  Providing this implies -MarkdownTable
    [Parameter(ValueFromPipelineByPropertyName)]
    [PSObject[]]
    $Property,

    # A heading.
    # If provided without -HeadingSize, -HeadingSize will default to 2.
    # If provided with -InputObject, -Heading will take priority.
    [Parameter(ValueFromPipelineByPropertyName)]    
    [string]
    $Heading,

    # The heading size (1-6)
    # If provided without -Heading, the -InputObject will be considered to be a heading.
    [Parameter(ValueFromPipelineByPropertyName)]
    [ValidateRange(1,6)]
    [int]
    $HeadingSize,

    # If set, will create a link.  The -InputObject will be used as the link content    
    [Parameter(ValueFromPipelineByPropertyName)]
    [Alias('Hyperlink', 'Href')]
    [string]
    $Link,

    # If set, will create an image link.  The -Inputobject will be used as the link content.
    [Parameter(ValueFromPipelineByPropertyName)]
    [string]
    $ImageLink,

    # If set, will generate a bullet point list.
    [Parameter(ValueFromPipelineByPropertyName)]
    [Alias('BulletpointList')]
    [switch]
    $BulletPoint,
    
    # If set, bullet or numbered list items will have a checkbox.
    # Each piped -InputObject will be an additional list item.
    [Parameter(ValueFromPipelineByPropertyName)]
    [switch]
    $Checkbox,

    # If set, bullet or numbered list items will be checked.
    [Parameter(ValueFromPipelineByPropertyName)]
    [switch]
    $Checked,

    # If set, will generate a numbered list.
    # Each piped -InputObject will be an additional list item.
    [Parameter(ValueFromPipelineByPropertyName)]
    [switch]
    $NumberedList,

    # If set, will generate a block quote.
    # Each line of the -InputObject will be block quoted.
    [Parameter(ValueFromPipelineByPropertyName)]
    [switch]
    $BlockQuote,

    # If set, will generate a block quote of a particular depth.
    # Each line of the -InputObject will be block quoted.
    [Parameter(ValueFromPipelineByPropertyName)]
    [ValidateRange(1,3)]
    [int]
    $BlockQuoteDepth,
        
    # If provided, will create a markdown numbered list with this particular item as the number.
    [Parameter(ValueFromPipelineByPropertyName)]
    [int]
    $Number,

    # If set, will generate a horizontal rule.  
    # If other parameters are provided, the horiztonal rule will be placed after.
    [Parameter(ValueFromPipelineByPropertyName)]
    [switch]
    $HorizontalRule,

    # If set, will output the -InputObject as a Markdown code block
    [Parameter(ValueFromPipelineByPropertyName)]
    [switch]
    $Code,

    # If set, will output the -InputObject as a Markdown code block, with a given language
    # If the -InputObject is a ScriptBlock, -CodeLanguage will be set to PowerShell.
    [Parameter(ValueFromPipelineByPropertyName)]
    [string]
    $CodeLanguage,

    # If provided, will output a script block as a Markdown code block.
    [Parameter(ValueFromPipelineByPropertyName)]
    [ScriptBlock]
    $ScriptBlock
    )

    begin {
        $numberedListCounter = 0
        $IsFirst = $true
        filter LinkInput {
            $in = $_
            if ($ImageLink) {
                "![$in]($imageLink)"
            } elseif ($link) {
                "[$in]($link)"
            } else {
                "$in"
            }
        }

        $markdownLines = @()
    }

    process {
        
        if ($ScriptBlock -or $inputObject -is [scriptblock]) {  # If a -ScriptBlock was provided
            $CodeLanguage = 'PowerShell' # use PowerShell as a Code Language.
        }

        # If a -HeadingSize or a -Heading were provided, render a heading.
        if ($HeadingSize -or $Heading) 
        {  
            if (-not $HeadingSize) { $HeadingSize = 2} # If the -HeadingSize was not set, set it to 2.
            $headingContent = "$(if ($Heading) { $Heading} else { $inputObject | LinkInput})"
            $markdownLines += 
                if ($HeadingSize -eq 1) {                
                    $headingContent
                    '=' * [Math]::Max($headingContent.Length, 3)
                }
                elseif ($HeadingSize -eq 2) {
                    $headingContent
                    '-' * [Math]::Max($headingContent.Length, 3)
                }
                else  {
                    ("#"*$HeadingSize) + " $headingContent" # Output the -Heading or the -InputObject.
                }
        }
        # If -Code or -CodeLanguage was provided, render a Markdown code block.
        elseif ($Code -or $CodeLanguage)
        { 
            # If the -InputObject was a [ScriptBlock] or there is a -ScriptBlock 
            if ($InputObject -is [scriptblock] -or $ScriptBlock) {
                $CodeLanguage  = 'PowerShell' # set the code language to PowerShell.
            }
            $markdownLines += (
                '```' + # Start the code fence,
                    $(if ($CodeLanguage) { $CodeLanguage}) + # add the language,
                    [Environment]::newline + # then a newline,
                    $(
                        $codeContent = $(if ($ScriptBlock) { "$scriptBlock" } else { $inputObject | LinkInput})  # then the -ScriptBlock or -InputObject
                        $codeContent
                    ) +
                    [Environment]::newline + # then a newline
                '```' # then close the code fence.
            )
        }
        # If -BulletPoint was passed, render a Bullet Point list.
        elseif ($BulletPoint) 
        { 
            $markdownLines += "*$(if ($Checkbox) { "[$(if ($Checked) {"x"} else {" "})]"}) $($inputObject | LinkInput)"
        }
        # If -NumberedList was passed, render a numbered list.
        elseif ($NumberedList -or $Number) 
        {
            $numberedListCounter++ # Increment the counter
            $markdownLines += "$(if ($number) { $number } else {$numberedListCounter}).$(if ($Checkbox) {" [$(if ($Checked) {"x"} else {" "})]"}) $($inputObject | LinkInput)"
        }
        elseif ($BlockQuote -or $BlockQuoteDepth) {
            if (-not $BlockQuoteDepth) { $BlockQuoteDepth = 1 }
            $markdownLines += ("&gt;" * $BlockQuoteDepth ) + ' ' + (
                "$inputObject" -split '(?&gt;\r\n|\n)' -join (
                    [Environment]::NewLine + ("&gt;" * $BlockQuoteDepth) + ' '
                )
            )
        }
        # Otherwise, we have to determine if -InputObject should be a -MarkdownTable or a -MarkdownParagraph.
        else
        {
            # If the input is a primitive type or a string, it should be a markdown paragraph
            if (($inputObject.GetType -and $inputObject.GetType().IsPrimitive) -or 
                $inputObject -is [string]) {
                $MarkdownParagraph = $true
            }
            # If it is a dictionary, it should be a markdown table.
            elseif ($inputObject -is [Collections.IDictionary]) 
            {
                $MarkdownTable = $true
            }
            # If the input is an array, apply the same logic:
            elseif ($inputObject -is [Object[]] -or $InputObject -is [PSObject[]]) {
                $allPrimitives = 1
                # if the array was all primitives or strings                
                foreach ($in in $InputObject) {
                    $allPrimitives = $allPrimitives -band (
                        ($in.GetType -and $in.GetType().IsPrimitive) -or $in -is [string]
                    )
                }
                if ($allPrimitives) { # output as a paragraph.
                    $MarkdownParagraph = $true
                } else {
                    $MarkdownTable = $true
                }
            }
            # If we're still not sure, output as a table.                     
            else {
                $MarkdownTable = $true
            }
        }

        if ($MarkdownParagraph) {
            # If we're outputting as a paragraph, add the input and link it if needed.
            $markdownLines += $inputObject | LinkInput
        } elseif ($MarkdownTable) {
            # If we're rendering a table, we need to go row-by-row.
            foreach ($in in $InputObject) {
                $propertyList = @(
                    # we first need to get a list of properties.
                    # If there was a -Property parameter provided, use it.
                    if ($Property) {
                        foreach ($prop in $Property) {
                            if ($prop -is [string]) { # Strings in -Property should be taken as property names
                                $prop
                            } elseif ($prop.Name -and $prop.Expression -and $prop.Expression -is [scriptblock]) {
                                # and anything with a name and expression script block will run the expression script block.
                                $_ = $psItem = $in
                                @{name=$prop.Name;Value = . $prop.Expression}
                            }
                        }
                    } 
                    # Otherwise, if the input was a dictionary
                    elseif ($in -is [Collections.IDictionary]) 
                    {
                        foreach ($k in $in.Keys) { # take all keys from the dictionary
                            if ($MyInvocation.MyCommand.Parameters[$k]) { continue } # that are not parameters of this function.
                            $k
                        }                        
                    }
                    # Otherwise, walk over all properties on the object
                    else {
                        foreach ($psProp in $In.psobject.properties) {
                            # and skip any properties that are parameters of this function.
                            if ($psProp.Name -notin $MyInvocation.MyCommand.Parameters.Keys) {
                                $psProp
                            }
                        }
                    }
                )

                # If we're rendering the first row of a table
                if ($IsFirst) {
                    # Create the header
                    $markdownLines +=
                        '|' + (@(foreach ($prop in $propertyList) {
                            if ($prop -is [string]) {
                                $prop
                            } else {
                                $prop.Name
                            }
                        }) -replace ([Environment]::newline), '&lt;br/&gt;' -replace '\|', '\|' -join '|') + '|'
                    # Then create the alignment row.
                    $markdownLines +=
                        '|' + $(
                            $columnNumber =0 
                            @(
                                foreach ($prop in $propertyList) {
                                    $colLength = 
                                        if ($prop -is [string]) {
                                            $prop.Length
                                        } else {
                                            $prop.Name.Length
                                        }
                                    if ($MarkdownTableAlignment) {
                                        if ($MarkdownTableAlignment[$columnNumber] -eq 'Left') {
                                            ':' + ("-" * ([Math]::Max($colLength,2) - 1))
                                        }
                                        elseif ($MarkdownTableAlignment[$columnNumber] -eq 'Right') {
                                            ("-" * ([Math]::Max($colLength,2) - 1)) + ':'
                                        }
                                        elseif ($MarkdownTableAlignment[$columnNumber] -eq 'Center') {
                                            ':' + ("-" * ([Math]::max($colLength, 3) - 2)) + ':'
                                        } else {
                                            "-" * $colLength
                                        }
                                    } else {
                                        "-" * $colLength
                                    }
                                    
                                    $columnNumber++
                                }
                            ) -replace ([Environment]::newline), '&lt;br/&gt;' -replace '\|', '\|' -join '|') + '|'                    
                    $IsFirst = $false
                }
                
                # Now we create the row for this object.

                $markdownLine = '|' + (
                    @(
                        foreach ($prop in $propertyList) {
                            if ($prop -is [string]) {
                                $in.$prop | LinkInput
                            } else {
                                $prop.Value | LinkInput
                            }
                        }
                    ) -replace ([Environment]::newline), '&lt;br/&gt;' -replace '\|', '\|' -join '|') + '|'

                $markdownLines += $markdownLine
            }                                    
        }

            
        if (  # There are a few combinations of parameters that make us want to write the -InputObject as a paragraph:
            ($ScriptBlock -and $inputObject) -or # * If -ScriptBlock and -InputObject were both provided.
            ($Heading -and $inputObject)         # * if -Heading and -InputObject were both provided
        ) {
            $markdownLines += $InputObject | LinkInput
        }


        # If we're going to render a horizontal rule (and -MarkdownTable has not been set)
        if ($HorizontalRule -and -not $MarkdownTable) {
            # add the horizontal rule at the end.
            if ($host.UI.RawUI.BufferSize.Width) {                
                $markdownLines += (([string]$HorizontalRuleCharacter) * ($Host.UI.RawUI.BufferSize.Width - 1))
            } else {
                $markdownLines += "---"
            }                        
        }
    }

    end {
        # Now we need to make one last pass to normalize tables
        if ($markdownLines -match '^\|') { # (that is, if we have tables to normalize).
            $maxColumnSize  = @{} # To normalize the table, we need to track the maximum size per column
            foreach ($ml in $markdownLines) {
                if ($ml -match '\^|') {
                    $columnCount = 0
                    foreach ($tablePart in $ml -split '(?&lt;!\\)\|' -ne '') {
                        if ((-not $maxColumnSize[$columnCount]) -or $maxColumnSize[$columnCount] -lt $tablePart.Length) {
                            $maxColumnSize[$columnCount] = [Math]::Max($tablePart.Length, 2)
                        }
                        $columnCount++
                    }
                }
            }
            # One we know the maximum size per column, walk over each line
            $markdownLines = @(foreach ($ml in $markdownLines) {
                if ($ml -match '\^|') {
                    $columnCount = 0
                    # Recreate the line with the right amount of padding.
                    '|' + (@(foreach ($tablePart in $ml -split '(?&lt;!\\)\|' -ne '') {
                        if ($tablePart -match '^[:\-]+$') {
                            if ($tablePart -match '^\:-{0,}\:$') { # If it's an alignment column, make sure to keep the alignment.
                                if ($maxColumnSize[$columnCount] -gt 2) {
                                    ':' + ('-' * ($maxColumnSize[$columnCount] - 2)) + ':'
                                } else {
                                    '::'
                                }
                            }
                            elseif ($tablePart -match '\:$') {
                                $tablePart.PadLeft($maxColumnSize[$columnCount], '-')
                            } 
                            elseif ($tablePart -match '^\:') {
                                $tablePart.PadRight($maxColumnSize[$columnCount], '-')
                            }
                            else {
                                $tablePart.PadRight($maxColumnSize[$columnCount], '-')
                            }
                        } else {
                            $tablePart.PadRight($maxColumnSize[$columnCount], ' ')
                        }
                        $columnCount++                                            
                    }) -join '|') + '|'
                } else {
                    $ml
                }
            })
        }
        $markdownLines -join [Environment]::NewLine        
    }
</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>${Posh_Format-Heatmap}</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>
    &lt;#
    .SYNOPSIS
        Formats a value as a heatmap
    .DESCRIPTION
        Returns the color used to generate a heatmap for a given value.
    #&gt;
    [Management.Automation.Cmdlet("Format", "Object")]
    [ValidateScript({return $true})]
    param(
    # The value that will be heatmapped.
    [Parameter(ValueFromPipeline)]    
    $InputObject,
    
    # The Heatmap maximum, by default 1gb
    [Parameter(Mandatory)]    
    $HeatMapMax = 1gb,
    
    # The Heatmap middle value, by default 512mb
    $HeatMapMiddle = 512mb,
    
    # The Heatmap minimum value, by default 0
    $HeatMapMin = 0,
    
    # The color for cool.
    # To pass a Hex color as an int, simply replace # with 0x
    # (e.g. 0x00ff00 for green instead of '#00ff00') 
    [int]
    $HeatMapCool =0x05dd00,
    
    # The color for hot.
    # To pass a Hex color as an int, simply replace # with 0x
    # (e.g. 0xff0000 for red instead of '#ff0000') 
    [int]
    $HeatMapHot = 0xef1100
    )

    process {
        # Separate out the segments of the color,
        $coolRedPart = [byte](($HeatMapCool -band 0xff0000) -shr 16) # by bitmasking and then shifting right until it's bytes
        $coolGreenPart = [byte](($HeatMapCool -band 0x00ff00) -shr 8)
        $coolBluePart = [byte]($HeatMapCool -band 0x0000ff)

        $hotRedPart = [byte](($HeatMapHot  -band 0xff0000) -shr 16)
        $hotGreenPart = [byte](($HeatMapHot -band 0x00ff00) -shr 8)
        $hotBluePart = [byte]($HeatMapHot -band 0x0000ff)

        "#{0:x2}{1:x2}{2:x2}" -f @(
        if ($InputObject -le $HeatMapMin) 
        {
            $coolRedPart, $coolGreenPart, $coolBluePart
        }
        elseif ($InputObject -ge $HeatMapMax) 
        {
            $hotRedPart, $hotGreenPart, $hotBluePart
        } else {
            if ($InputObject -le $HeatMapMiddle) 
            {
                $d = 1 - ([double]$InputObject / ($HeatMapMiddle - $HeatMapMin))
                [Byte][Math]::Min(255, $hotRedPart * $d + $coolRedPart)
                [Byte][Math]::Min(255, $hotGreenPart * $d + $coolGreenPart)            
                [Byte][Math]::Min(255, $hotBluePart * $d + $coolBluePart)
            } else
            {
                $d = 1 - ([double]$InputObject / ($HeatMapMax - $HeatMapMiddle))
                [Byte][Math]::Min(255, $coolRedPart * $d + $hotRedPart)
                [Byte][Math]::Min(255, $coolGreenPart * $d + $hotGreenPart)            
                [Byte][Math]::Min(255, $coolBluePart * $d + $hotBluePart)
            }
        })
    }
</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
    <Control>
      <Name>${Posh_Format-RichText}</Name>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>
    &lt;#
    .Synopsis
        Formats the text color of output
    .Description
        Formats the text color of output

        * ForegroundColor
        * BackgroundColor
        * Bold
        * Underline
    .Notes
        Stylized Output works in two contexts at present:
        * Rich consoles (Windows Terminal, PowerShell.exe, Pwsh.exe) (when $host.UI.SupportsVirtualTerminal)
        * Web pages (Based off the presence of a $Request variable, or when $host.UI.SupportsHTML (you must add this property to $host.UI))
    #&gt;
    [Management.Automation.Cmdlet("Format","Object")]
    [ValidateScript({
        $canUseANSI     = $host.UI.SupportsVirtualTerminal
        $canUseHTML     = $Request -or $host.UI.SupportsHTML -or $OutputMode -eq 'HTML'
        if (-not ($canUseANSI -or $canUseHTML)) { return $false}
        return $true
    })]
    [OutputType([string])]
    param(
    # The input object
    [Parameter(ValueFromPipeline)]
    [PSObject]
    $InputObject,
    
    # The foreground color
    [string]$ForegroundColor,

    # The background color
    [string]$BackgroundColor,

    # If set, will render as bold
    [switch]$Bold,

    # If set, will render as italic.
    [Alias('Italics')]
    [switch]$Italic,

    # If set, will render as faint
    [switch]$Faint,

    # If set, will render as hidden text.
    [switch]$Hide,

    # If set, will render as blinking (not supported in all terminals or HTML)
    [switch]$Blink,    

    # If set, will render as strikethru
    [Alias('Strikethrough', 'Crossout')]
    [switch]$Strikethru,

    # If set, will underline text
    [switch]$Underline,

    # If set, will double underline text.
    [switch]$DoubleUnderline,    

    # If set, will invert text
    [switch]$Invert,

    # If provided, will create a hyperlink to a given uri
    [Alias('Hyperlink', 'Href')]
    [uri]
    $Link,

    # If set, will not clear formatting
    [switch]$NoClear,

    # The alignment.  Defaulting to Left.
    # Setting an alignment will pad the remaining space on each line.
    [ValidateSet('Left','Right','Center')]
    [string]
    $Alignment,

    # The length of a line.  By default, the buffer width
    [int]$LineLength = $($host.UI.RawUI.BufferSize.Width)
    )    

    begin {
        $canUseANSI     = $host.UI.SupportsVirtualTerminal
        $canUseHTML     = $Request -or $host.UI.SupportsHTML -or $OutputMode -eq 'HTML'
        $knownStreams = @{
            Output='';Error='BrightRed';Warning='BrightYellow';
            Verbose='BrightCyan';Debug='Yellow';Progress='Cyan';
            Success='BrightGreen';Failure='Red';Default=''}

        $ansiCode = [Regex]::new(@'
        (?&lt;ANSI_Code&gt;
        (?-i)\e                                                                                   # An Escape
        \[                                                                                        # Followed by a bracket
        (?&lt;ParameterBytes&gt;[\d\:\;\&lt;\=\&gt;\?]{0,})                                                   # Followed by zero or more parameter  
        bytes
        (?&lt;IntermediateBytes&gt;[\s\!\"\#\$\%\&amp;\'\(\)\*\+\,\-\.\/]{0,})                              # Followed by zero or more 
        intermediate bytes
        (?&lt;FinalByte&gt;[\@ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\\\]\^_\`abcdefghijklmnopqrstuvwxyz\{\|\}\~]) # Followed by a final byte
        
        )                
'@)
        $esc = [char]0x1b
        $standardColors = 'Black', 'Red', 'Green', 'Yellow', 'Blue','Magenta', 'Cyan', 'White'
        $brightColors   = 'BrightBlack', 'BrightRed', 'BrightGreen', 'BrightYellow', 'BrightBlue','BrightMagenta', 'BrightCyan', 'BrightWhite'

        $allOutput      = @()

        $n =0
        $cssClasses = @()        
        $colorAttributes =         
            @(:nextColor foreach ($hc in $ForegroundColor,$BackgroundColor) {
                $n++
                if (-not $hc) { continue }
                if ($hc[0] -eq $esc) {
                    if ($canUseANSI) { 
                        $hc; continue
                    }
                }
        
                $ansiStartPoint = if ($n -eq 1) { 30 } else { 40 } 
                if ($knownStreams.ContainsKey($hc)) {
                    $i = $brightColors.IndexOf($knownStreams[$hc])
                    if ($canUseHTML) {
                        $cssClasses += $hc
                    } else {
                        if ($i -ge 0 -and $canUseANSI) {
                            '' + $esc + "[1;$($ansiStartPoint + $i)m"
                        } else {
                            $i = $standardColors.IndexOf($knownStreams[$hc])
                            if ($i -ge 0 -and $canUseANSI) {
                                '' + $esc + "[1;$($ansiStartPoint + $i)m"
                            } elseif ($i -le 0 -and $canUseANSI) {                        
                                '' + $esc + "[$($ansistartpoint + 8):5m"
                            }
                        }
                    }
                    continue nextColor
                }
                elseif ($standardColors -contains $hc) {
                    for ($i = 0; $i -lt $standardColors.Count;$i++) {
                        if ($standardColors[$i] -eq $hc) {
                            if ($canUseANSI -and -not $canUseHTML) {
                                '' + $esc + "[$($ansiStartPoint + $i)m"
                            } else {
                                $cssClasses += $standardColors[$i]
                            }
                            continue nextColor
                        }
                    }
                } elseif ($brightColors -contains $hc) {
                    for ($i = 0; $i -lt $brightColors.Count;$i++) {
                        if ($brightColors[$i] -eq $hc) {
                            if ($canUseANSI -and -not $canUseHTML) {
                                '' + $esc + "[1;$($ansiStartPoint + $i)m"
                            } else {
                                $cssClasses += $standardColors[$i]
                            }
                            continue nextColor
                        }
                    }
                }                
                elseif ($psStyle -and $psStyle.Formatting.$hc -and 
                    $psStyle.Formatting.$hc -match '^\e') {
                    if ($canUseANSI -and -not $canUseHTML) {
                        $psStyle.Formatting.$hc
                    } else {
                        $cssClasses += "formatting-$hc"
                    }
                }
                elseif (-not $n -and $psStyle -and $psStyle.Foreground.$hc -and 
                    $psStyle.Foreground.$hc -match '^\e' ) {
                    if ($canUseANSI -and -not $canUseHTML) {
                        $psStyle.Foreground.$hc
                    } else {
                        $cssClasses += "foreground-$hc"
                    }                   
                }
                elseif ($n -and $psStyle -and $psStyle.Background.$hc -and
                    $psStyle.Background.$hc -match '^\e') {
                    if ($canUseANSI -and -not $canUseHTML) {
                        $psStyle.Background.$hc
                    } else {
                        $cssClasses += "background-$hc"
                    }                    
                }

        
        
                if ($hc -and $hc -notmatch '^[\#\e]') {
                    $placesToLook=
                        @(if ($hc.Contains('.')) {
                            $module, $setting = $hc -split '\.', 2
                            $theModule = Get-Module $module
                            $theModule.PrivateData.Color,
                                $theModule.PrivateData.Colors,
                                $theModule.PrivateData.Colour,
                                $theModule.PrivateData.Colours,
                                $theModule.PrivateData.EZOut,
                                $global:PSColors,
                                $global:PSColours
                        } else {
                            $setting = $hc
                            $moduleColorSetting = $theModule.PrivateData.PSColors.$setting
                        })
        
                    foreach ($place in $placesToLook) {
                        if (-not $place) { continue }
                        foreach ($propName in $setting -split '\.') {
                            $place = $place.$propName
                            if (-not $place) { break }
                        }
                        if ($place -and "$place".StartsWith('#') -and 4,7 -contains "$place".Length) {
                            $hc = $place
                            continue
                        }
                    }
                    if (-not $hc.StartsWith -or -not $hc.StartsWith('#')) {
                        continue
                    }
                }
                $r,$g,$b = if ($hc.Length -eq 7) {
                    [int]::Parse($hc[1..2]-join'', 'HexNumber')
                    [int]::Parse($hc[3..4]-join '', 'HexNumber')
                    [int]::Parse($hc[5..6] -join'', 'HexNumber')
                }elseif ($hc.Length -eq 4) {
                    [int]::Parse($hc[1], 'HexNumber') * 16
                    [int]::Parse($hc[2], 'HexNumber') * 16
                    [int]::Parse($hc[3], 'HexNumber') * 16
                }
        
                if ($canUseHTML) {
                    if ($n -eq 1) { "color:$hc" }
                    elseif ($n -eq 2) { "background-color:$hc"} 
                }
                elseif ($canUseANSI) {
                    if ($n -eq 1) { $esc+"[38;2;$r;$g;${b}m" }
                    elseif ($n -eq 2) { $esc+"[48;2;$r;$g;${b}m" }
                }
                
            })
        
        $styleAttributes = @() + $colorAttributes
        
        $styleAttributes += @(
            if ($Bold) {
                if ($canUseHTML) {"font-weight:bold"}
                elseif ($canUseANSI) { '' + $esc + "[1m" }
            }
            if ($Faint) {
                if ($canUseHTML) { "opacity:.5" }
                elseif ($canUseANSI) { '' + $esc + "[2m" }
            }
            if ($Italic) {                
                if ($canUseHTML) { "font-weight:bold" }
                elseif ($canUseANSI)  {'' + $esc + "[3m" }
            }
            
            if ($Underline -and -not $doubleUnderline) {             
                if ($canUseHTML) { "text-decoration:underline"} 
                elseif ($canUseANSI) {'' +$esc + "[4m" }
            }

            if ($Blink) {             
                if ($canUseANSI) { '' +$esc + "[5m" }
            }

            if ($invert) {
                if ($canUseHTML) {"filter:invert(100%)"}
                elseif ($canUseANSI) { '' + $esc + "[7m"}
            }

            if ($hide) {
                if ($canUseHTML) {"opacity:0"}
                elseif ($canUseANSI) { '' + $esc + "[8m"}
            }
            
            if ($Strikethru) {             
                if ($canUseHTML) {"text-decoration: line-through"}
                elseif ($canUseANSI) { '' +$esc + "[9m" }
            }
            
            if ($DoubleUnderline) {
                if ($canUseHTML) { "border-bottom: 3px double;"}
                elseif ($canUseANSI) {'' +$esc + "[21m" }
            }

            if ($Alignment -and $canUseHTML) {
                "display:block;text-align:$($Alignment.ToLower())"
            }

            if ($Link) {
                if ($canUseHTML) { 
                    # Hyperlinks need to be a nested element
                    # so we will not add it to style attributes for HTML
                }
                elseif ($canUseANSI) {
                    # For ANSI,
                    '' + $esc + ']8;;' + $Link + $esc + '\'   
                }
            }
            
        )
        
        $header =
            if ($canUseHTML) {        
                "&lt;span$(
                    if ($styleAttributes) { " style='$($styleAttributes -join ';')'"}
                )$(
                    if ($cssClasses) { " class='$($cssClasses -join ' ')'"}
                )&gt;" + $(
                    if ($Link) {
                        "&lt;a href='$link'&gt;"
                    }
                )
            } elseif ($canUseANSI) {
                $styleAttributes -join ''
            }
    }

    process {
        $inputObjectAsString =
            "$(if ($inputObject) { $inputObject | Out-String})".Trim()

        $inputObjectAsString = 
            if ($Alignment -and -not $canUseHTML) {
                (@(foreach ($inputObjectLine in ($inputObjectAsString -split '(?&gt;\r\n|\n)')) {
                    $inputObjectLength = $ansiCode.Replace($inputObjectLine, '').Length
                    if ($inputObjectLength -lt $LineLength) {
                        if ($Alignment -eq 'Left') {
                            $inputObjectLine
                        } elseif ($Alignment -eq 'Right') {
                            (' ' * ($LineLength - $inputObjectLength)) + $inputObjectLine                            
                        } else {
                            $half = ($LineLength - $inputObjectLength)/2
                            (' ' * [Math]::Floor($half)) + $inputObjectLine +
                            (' ' * [Math]::Ceiling($half))
                        }
                    }
                    else {
                        $inputObjectLine
                    }
                }) -join [Environment]::NewLine) + [Environment]::newline
            } else {
                $inputObjectAsString
            }

        $allOutput +=
            if ($header) {
                "$header" + $inputObjectAsString
            }
            elseif ($inputObject) {
                $inputObjectAsString
            }
    }

    end {
        
        if (-not $NoClear) {
            $allOutput += 
                if ($canUseHTML) {
                    if ($Link) {
                        "&lt;/a&gt;"
                    }
                    "&lt;/span&gt;"
                }
                elseif ($canUseANSI) {
                    if ($Bold -or $Faint -or $colorAttributes -match '\[1;') {
                        "$esc[22m"
                    }
                    if ($Italic) {
                        "$esc[23m"
                    }
                    if ($Underline -or $doubleUnderline) {
                        "$esc[24m"
                    }
                    if ($Blink) {
                        "$esc[25m"
                    }                
                    if ($Invert) {
                        "$esc[27m"
                    }
                    if ($hide) {
                        "$esc[28m"
                    }
                    if ($Strikethru) {
                        "$esc[29m"
                    }
                    if ($ForegroundColor) {
                        "$esc[39m"
                    }
                    if ($BackgroundColor) {
                        "$esc[49m"
                    }

                    if ($Link) {
                        "$esc]8;;$esc\"
                    }
                
                    if (-not ($Underline -or $Bold -or $Invert -or $ForegroundColor -or $BackgroundColor)) {
                        '' + $esc + '[0m'
                    }
                }
        }

        $allOutput -join ''
    }
</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </Control>
  </Controls>
  <ViewDefinitions>
    <View>
      <Name>FileSystemTypes</Name>
      <ViewSelectedBy>
        <SelectionSetName>FileSystemTypes</SelectionSetName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>PSParentPath</PropertyName>
        <CustomControlName>FileSystemTypes-GroupingFormat</CustomControlName>
      </GroupBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
            <Alignment>Right</Alignment>
            <Width>22</Width>
          </TableColumnHeader>
          <TableColumnHeader>
            <Label>Length</Label>
            <Alignment>Right</Alignment>
            <Width>10</Width>
          </TableColumnHeader>
          <TableColumnHeader>
            <Label>Name</Label>
            <Alignment>Left</Alignment>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>LastWriteTime</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <ScriptBlock>
        if ($_.Length) {
            if ($_.Length / 1gb -eq 1) {
                '' + $([Math]::Round($_.Length / 1gb, 2)) + 'gb'
            }
            elseif ($_.Length / 1mb -ge 1) {
                '' + $([Math]::Round($_.Length / 1mb, 2)) + 'mb'
            }
            elseif ($_.Length -gt 1kb) {
                '' + $([Math]::Round($_.Length / 1kb, 2)) + 'kb'
            } elseif ($_ -isnot [IO.DirectoryInfo]) {
                $_.Length
            }
        }
    </ScriptBlock>
              </TableColumnItem>
              <TableColumnItem>
                <ScriptBlock>
        $fileInfo = $_
        $formatTerminalIcons = $($executionContext.sessionState.InvokeCommand.GetCommands('Format-TerminalIcons', 'Function', $false))
        
        @(if ($formatTerminalIcons) {
            . $formatTerminalIcons $_
        } else {
            
            $(if ($_ -is [IO.DirectoryInfo]) {                
                $PSStyle.FileInfo.Directory
                if ($PSStyle.FileInfo.DirectoryIcon) {
                    "$($PSStyle.FileInfo.DirectoryIcon)" + " "
                } else {
                    "▶ "
                }
                
            } else {
                if (
                    $PSStyle.FileInfo.Extension.Keys -and 
                    $PSStyle.FileInfo.Extension[$_.Extension]
                ) {
                    $PSStyle.FileInfo.Extension[$_.Extension]
                }
                
                if ($psStyle.FileInfo.Pattern.Keys -and $(
                    $MatchingPatterns = 
                        @(foreach ($filePattern in $psStyle.FileInfo.Pattern.Keys) {
                            if ($fileInfo.Name -match $filePattern -or 
                                $fileInfo.Fullname -match $filePattern) {
                                $filePattern                            
                            }
                        })
                    $MatchingPatterns
                )
                ) {
                    foreach ($MatchingPattern in $MatchingPatterns) {
                        $PSStyle.FileInfo.Pattern[$MatchingPattern]
                    }
                }
                
                
                
                $extraSpace = $true
                if ($psStyle.FileInfo.ExtensionIcon -and $psStyle.FileInfo.ExtensionIcon[$_.Extension]) {
                    "$($psStyle.FileInfo.ExtensionIcon[$_.Extension]) "
                } else {
                    
                    $(switch ($_.Extension) {
                        .ps1 {
                            "⟩"
                        }
                        .sh {'⟩'}
                        .zip {
                           "⧯" 
                        }
                        .deb {"⧯"}
                        .pkg {"⧯"}
                        .nupkg {"⧯"}
                        .msixbundle {"⧯"}
                        .srt { '⧳'}
                        .vtt { '⧳'}
                        .exe {
                            '⋇'
                        }
                        .psd1 {
                           "⧳" # ⨇ 
                        }
                        .psm1 {
                            '⧳' # '⨈'
                        }
                        .ttf { '🗛'}
                        .woff { '🗛'}
                        .fon { '🗛'}
                        .ttc { '🗛'}
                        .json {
                           "⧳" 
                        }
                        .mp3 {'♬'}
                        .wav {'♬'}
                        .txt { 
                            '≣'                            
                        }
                        .md {
                            '≣'                            
                        }
                        .inf {'⚙' }
                        .ini {'⚙ '}
                        .mpg {'▰' }
                        .mp4 {'▰' }
                        .mkv {'▰' }
                        .avi {'▰' }
                        .gif {'▰' }
                        .jpg { '▭' }
                        .png { '▭' }                        
                        .svg { '⬢' }
                        .ico { '⬢' }
                        
                        .ps1xml { "⧳"}
                        .clixml { "⧳"}
                        .clix { "⧳" }
                        .xml { "⧳" }
                        
                        default {
                            " "
                        }
                    }) + $(if ($extraSpace) { ' ' })
                    
                }

                
            }) + $(
                if ($PSStyle.FormatHyperlink -and -not $env:GITHUB_WORKSPACE) {
                    $PSStyle.FormatHyperlink($fileInfo.Name, [uri]$fileInfo.Fullname)
                } else {
                    $fileInfo.Name
                }
            )
                        
            $PSStyle.Reset
        }) -ne '' -join ''

        
    </ScriptBlock>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>FileSystemTypes</Name>
      <ViewSelectedBy>
        <SelectionSetName>FileSystemTypes</SelectionSetName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>$script:TreeDepth = 0;$true</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$_</ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>FileSystemTypes.TreeNode</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>$executionContext.SessionState.PSVariable.Remove("script:TreeDepth");$false</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$null</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Posh</Name>
      <ViewSelectedBy>
        <TypeName>Posh</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.Blue','Bold') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>Name</PropertyName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.Cyan') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <Text> @ </Text>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>Version</PropertyName>
                <CustomControlName>VersionControl</CustomControlName>
              </ExpressionBinding>
              <NewLine />
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.Blue','Italic') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        $_.Description
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.Green') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        $_.PrivateData.ExtendedDescription
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.Magenta') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>        
        "To see PowerShell tips, try `$posh.Tips",
        "To see PowerShell links, use `$Posh.Links",
        "To see PowerShell module recommendations, get `$Posh.Recommends",
        "To see PowerShell news, get `$Posh.News" | Get-Random
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.Cyan') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
"
To see everything Posh can do: `$posh | Get-Member
"
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <NewLine />
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Posh.Host</Name>
      <ViewSelectedBy>
        <TypeName>Posh.Host</TypeName>
      </ViewSelectedBy>
      <TableControl>
        <AutoSize />
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>Name</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>CurrentCulture</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>Width</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>Height</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>Posh.Input</Name>
      <ViewSelectedBy>
        <TypeName>Posh.Input</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>
        Show-Markdown -InputObject $_.README
    </ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.Cyan') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        "To reset the input, use `$posh.Input.Clear()"
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <NewLine />
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        $_.Stack.Count 
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.Yellow','Italic') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        $_.Stack.Count 
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        ('The input has ' + $_.Stack.Count + ' modification(s)')
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        $_.Stack.Count 
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Posh.Module.Link</Name>
      <ViewSelectedBy>
        <TypeName>Posh.Module.Link</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>Source</PropertyName>
      </GroupBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock> $_ </ScriptBlock>
                <CustomControlName>Posh.Link</CustomControlName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Posh.Module.Link</Name>
      <ViewSelectedBy>
        <TypeName>Posh.Module.Link</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>Source</PropertyName>
      </GroupBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>Name</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>Url</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>Posh.Module.Logo</Name>
      <ViewSelectedBy>
        <TypeName>Posh.Module.Logo</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>Source</PropertyName>
      </GroupBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>
    @(
    if ($_.Name -and $_.Url) {
        if ($psStyle.FormatHyperlink -and -not $env:GITHUB_WORKSPACE) {
            $psStyle.FormatHyperlink($_.Name, $_.Url)
        } else {
            "[$($_.Name)]($($_.Url))"
        }
    } elseif ($_.Url) {
        $uri = [uri]$_.Url
        if ($psStyle.FormatHyperlink -and -not $env:GITHUB_WORKSPACE) {
            $psStyle.FormatHyperlink($_.Url, $uri)
        } else {
            "[$($_.Url)]($($uri))"
        }        
    }    
    ) -join ''    
</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Posh.Module.Logo</Name>
      <ViewSelectedBy>
        <TypeName>Posh.Module.Logo</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>Source</PropertyName>
      </GroupBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>Name</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>Url</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>Posh.Module.Screenshot</Name>
      <ViewSelectedBy>
        <TypeName>Posh.Module.Screenshot</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>Source</PropertyName>
      </GroupBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock> $_ </ScriptBlock>
                <CustomControlName>Posh.Link</CustomControlName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Posh.Module.Screenshot</Name>
      <ViewSelectedBy>
        <TypeName>Posh.Module.Screenshot</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>Source</PropertyName>
      </GroupBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>Name</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>Url</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>Posh.Module.Video</Name>
      <ViewSelectedBy>
        <TypeName>Posh.Module.Video</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>Source</PropertyName>
      </GroupBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock> $_ </ScriptBlock>
                <CustomControlName>Posh.Link</CustomControlName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Posh.Module.Video</Name>
      <ViewSelectedBy>
        <TypeName>Posh.Module.Video</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>Source</PropertyName>
      </GroupBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>Name</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>Url</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>Posh.Parameters</Name>
      <ViewSelectedBy>
        <TypeName>Posh.Parameters</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>
        Show-Markdown -InputObject $_.README
    </ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.Cyan') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        "To add defaults, use `$posh.Parameters.SetDefault()"
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <NewLine />
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $global:PSDefaultParameterValues.Count </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$moduleName = 'Posh'

            do {
                $lm = Get-Module -Name $moduleName -ErrorAction Ignore
                if (-not $lm) { continue } 
                if ($lm.FormatPartsLoaded) { break }
                $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
                    foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
                        $ParentNode = $partNodeName.Node.ParentNode
                        "$($ParentNode.Name)={
            $($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
                    }
                }) -join [Environment]::NewLine
                New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
                    Import-Module -Global
                $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
                
                if (-not $lm.OnRemove) {
                    $lm.OnRemove = $onRemove
                } else {
                    $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
                }
                $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force
            
            } while ($false)
            
        

        &amp; ${Posh_Format-Yaml} -InputObject ($_.Defaults)
    </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Posh.Preset.Collection</Name>
      <ViewSelectedBy>
        <TypeName>Posh.Preset.Collection</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>
        Show-Markdown -InputObject $_.README
    </ScriptBlock>
              </ExpressionBinding>
              <NewLine />
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Posh.Profiles</Name>
      <ViewSelectedBy>
        <TypeName>Posh.Profiles</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>
        Show-Markdown -InputObject $_.README
    </ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <NewLine />
              <Text>The current profile is:</Text>
              <NewLine />
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Italic') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <PropertyName>Current</PropertyName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.Cyan') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        "To add to your profile, use `$posh.Profile.Add()"
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.Cyan') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        "To remove from your profile, use `$posh.Profile.Remove()"
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Posh.Prompt</Name>
      <ViewSelectedBy>
        <TypeName>Posh.Prompt</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.Green','Bold') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        Show-Markdown -InputObject $_.README
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.Cyan') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        "To reset the prompt, use `$posh.Prompt.Clear()"
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <NewLine />
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        $_.Stack.Count 
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.Yellow','Italic') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        $_.Stack.Count 
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        ('The prompt has ' + $_.Stack.Count + ' modification(s)')
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
        $_.Stack.Count 
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Posh.Recommendation</Name>
      <ViewSelectedBy>
        <TypeName>Posh.Recommendation</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>Source</PropertyName>
      </GroupBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>
    @(
    if ($_.Name -and $_.Url) {
        if ($psStyle.FormatHyperlink -and -not $env:GITHUB_WORKSPACE) {
            $psStyle.FormatHyperlink($_.Name, $_.Url)
        } else {
            "[$($_.Name)]($($_.Url))"
        }
    } elseif ($_.Url) {
        $uri = [uri]$_.Url
        if (-not $uri.Authority) {
            $uri = "https://www.powershellgallery.com/packages/$($uri)"
        }

        if ($psStyle.FormatHyperlink -and -not $env:GITHUB_WORKSPACE) {
            $psStyle.FormatHyperlink($_.Url, $uri)
        } else {
            "[$($_.Url)]($($uri))"
        }        
    }    
    ) -join ''    
</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Posh.Recommendation</Name>
      <ViewSelectedBy>
        <TypeName>Posh.Recommendation</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>Source</PropertyName>
      </GroupBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>Name</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>Url</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>Posh.RSS.Article</Name>
      <ViewSelectedBy>
        <TypeName>Posh.RSS.Article</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>Source</PropertyName>
      </GroupBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock> $_ </ScriptBlock>
                <CustomControlName>Posh.Link</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.DatePublished -is [datetime] </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
        " ($($_.DatePublished.ToShortDateString())) "
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.Enclosure </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> $_ </ScriptBlock>
                <CustomControlName>Posh.Link.Play</CustomControlName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Posh.RSS.Article</Name>
      <ViewSelectedBy>
        <TypeName>Posh.RSS.Article</TypeName>
      </ViewSelectedBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>Title</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>Link</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>Posh.RSS.Feed</Name>
      <ViewSelectedBy>
        <TypeName>Posh.RSS.Feed</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>Name</PropertyName>
      </GroupBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock> $_.Recent </ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>Posh.Link.Line</CustomControlName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>All</Name>
      <ViewSelectedBy>
        <TypeName>Posh.RSS.Feed</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>Name</PropertyName>
      </GroupBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock> $_.Article </ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>Posh.Link.Line</CustomControlName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Posh.RSS.FeedCollection</Name>
      <ViewSelectedBy>
        <TypeName>Posh.RSS.FeedCollection</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>
        Show-Markdown -InputObject $_.README
    </ScriptBlock>
              </ExpressionBinding>
              <NewLine />
              <ExpressionBinding>
                <ScriptBlock>if ($psStyle) {
   @(foreach ($styleProp in 'Foreground.Cyan') {

        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                    $targetObject -is [Collections.IDictionary]) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    

   }) -ne '' -join ''
}</ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
        @(
        "Feeds: "
        ""
        foreach ($feed in $_.All) {
            "* $($feed.Name)"
        }
        ) -join [Environment]::NewLine
    </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock>
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Posh.Tip.Collection</Name>
      <ViewSelectedBy>
        <TypeName>Posh.Tip.Collection</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <PropertyName>Random</PropertyName>
                <CustomControlName>Posh.Tip.Control</CustomControlName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Posh.Tip.Command</Name>
      <ViewSelectedBy>
        <TypeName>Posh.Tip.Command</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock> $_ </ScriptBlock>
                <CustomControlName>Posh.Tip.Control</CustomControlName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>System.Reflection.MemberInfo</Name>
      <ViewSelectedBy>
        <TypeName>System.Reflection.MemberInfo</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $ExecutionContext.SessionState.PSVariable.Set('Script:DisplayingMember',$true) </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> $null </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> $_ </ScriptBlock>
                <CustomControlName>TypeMemberControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $ExecutionContext.SessionState.PSVariable.Remove('Script:DisplayingMember') </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> $null </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>System.Type</Name>
      <ViewSelectedBy>
        <TypeName>System.Type</TypeName>
      </ViewSelectedBy>
      <TableControl>
        <AutoSize />
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>FullName</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>BaseType</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>IsPublic</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>IsSerializable</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>Inheritance</Name>
      <ViewSelectedBy>
        <TypeName>System.Type</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <ScriptBlock> 
    "
    ... | Format-Custom -View Full       # To show public and private members
    ... | Format-Custom -View Public     # To show public members
    ... | Format-Custom -View Private    # To show private members
    ... | Format-Custom -View Interfaces # To show interfaces
    "
    </ScriptBlock>
        <Label>Type Inheritance</Label>
      </GroupBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock> $_ </ScriptBlock>
                <CustomControlName>TypeInheritanceControl</CustomControlName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Interfaces</Name>
      <ViewSelectedBy>
        <TypeName>System.Type</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <ScriptBlock> 
    "
    ... | Format-Custom -View Full       # To show public and private members
    ... | Format-Custom -View Public     # To show public members
    ... | Format-Custom -View Private    # To show private members
    ... | Format-Custom -View Interfaces # To show interfaces
    "
    </ScriptBlock>
        <Label>Type Inheritance</Label>
      </GroupBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock> $_ </ScriptBlock>
                <CustomControlName>TypeInheritanceControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> $_.GetInterfaces() </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> $_.GetInterfaces() | Sort-Object Name</ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>TypeInterfaceControl</CustomControlName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Public</Name>
      <ViewSelectedBy>
        <TypeName>System.Type</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <ScriptBlock> 
    "
    ... | Format-Custom -View Full       # To show public and private members
    ... | Format-Custom -View Public     # To show public members
    ... | Format-Custom -View Private    # To show private members
    ... | Format-Custom -View Interfaces # To show interfaces
    "
    </ScriptBlock>
        <Label>Type Public</Label>
      </GroupBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
$_ |
    Add-Member NoteProperty '.View' 'Public' -PassThru -Force | 
    Add-Member NoteProperty '.BindingFlags' ([Reflection.BindingFlags]'Public') -Force
</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> "" </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> $_ </ScriptBlock>
                <CustomControlName>TypeInheritanceControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> 
        $_.GetInterfaces()
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> 
        $_.GetInterfaces() | Sort-Object Name
    </ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>TypeInterfaceControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> 
        if ($_.'.BindingFlags') {
            @{Type=$_;BindingFlags="Instance,$($_.'.BindingFlags')"}
        } else {
            $_
        }
    </ScriptBlock>
                <CustomControlName>TypeConstructorsControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> 
        if ($_.'.BindingFlags') {
            @{Type=$_;BindingFlags="Instance,$($_.'.BindingFlags')"}
        } else {
            $_
        }
    </ScriptBlock>
                <CustomControlName>TypeEventsControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> 
        if ($_.'.BindingFlags') {
            @{Type=$_;BindingFlags="$($_.'.BindingFlags')"}
        } else {
            $_
        }
    </ScriptBlock>
                <CustomControlName>TypePropertiesControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> 
        if ($_.'.BindingFlags') {
            @{Type=$_;BindingFlags="$($_.'.BindingFlags')"}
        } else {
            $_
        }
    </ScriptBlock>
                <CustomControlName>TypeMethodsControl</CustomControlName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Private</Name>
      <ViewSelectedBy>
        <TypeName>System.Type</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <ScriptBlock> 
    "
    ... | Format-Custom -View Full       # To show public and private members
    ... | Format-Custom -View Public     # To show public members
    ... | Format-Custom -View Private    # To show private members
    ... | Format-Custom -View Interfaces # To show interfaces
    "
    </ScriptBlock>
        <Label>Type Private</Label>
      </GroupBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
$_ |
    Add-Member NoteProperty '.View' 'Private' -PassThru -Force | 
    Add-Member NoteProperty '.BindingFlags' ([Reflection.BindingFlags]'NonPublic') -Force
</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> "" </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> $_ </ScriptBlock>
                <CustomControlName>TypeInheritanceControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> 
        $_.GetInterfaces()
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> 
        $_.GetInterfaces() | Sort-Object Name
    </ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>TypeInterfaceControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> 
        if ($_.'.BindingFlags') {
            @{Type=$_;BindingFlags="Instance,$($_.'.BindingFlags')"}
        } else {
            $_
        }
    </ScriptBlock>
                <CustomControlName>TypeConstructorsControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> 
        if ($_.'.BindingFlags') {
            @{Type=$_;BindingFlags="Instance,$($_.'.BindingFlags')"}
        } else {
            $_
        }
    </ScriptBlock>
                <CustomControlName>TypeEventsControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> 
        if ($_.'.BindingFlags') {
            @{Type=$_;BindingFlags="$($_.'.BindingFlags')"}
        } else {
            $_
        }
    </ScriptBlock>
                <CustomControlName>TypePropertiesControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> 
        if ($_.'.BindingFlags') {
            @{Type=$_;BindingFlags="$($_.'.BindingFlags')"}
        } else {
            $_
        }
    </ScriptBlock>
                <CustomControlName>TypeMethodsControl</CustomControlName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Full</Name>
      <ViewSelectedBy>
        <TypeName>System.Type</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <ScriptBlock> 
    "
    ... | Format-Custom -View Full       # To show public and private members
    ... | Format-Custom -View Public     # To show public members
    ... | Format-Custom -View Private    # To show private members
    ... | Format-Custom -View Interfaces # To show interfaces
    "
    </ScriptBlock>
        <Label>Type Full</Label>
      </GroupBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>
$_ |
    Add-Member NoteProperty '.View' 'Full' -PassThru -Force | 
    Add-Member NoteProperty '.BindingFlags' ([Reflection.BindingFlags]'Public,NonPublic') -Force
</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> "" </ScriptBlock>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> $_ </ScriptBlock>
                <CustomControlName>TypeInheritanceControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock> 
        $_.GetInterfaces()
    </ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> 
        $_.GetInterfaces() | Sort-Object Name
    </ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>TypeInterfaceControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> 
        if ($_.'.BindingFlags') {
            @{Type=$_;BindingFlags="Instance,$($_.'.BindingFlags')"}
        } else {
            $_
        }
    </ScriptBlock>
                <CustomControlName>TypeConstructorsControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> 
        if ($_.'.BindingFlags') {
            @{Type=$_;BindingFlags="Instance,$($_.'.BindingFlags')"}
        } else {
            $_
        }
    </ScriptBlock>
                <CustomControlName>TypeEventsControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> 
        if ($_.'.BindingFlags') {
            @{Type=$_;BindingFlags="$($_.'.BindingFlags')"}
        } else {
            $_
        }
    </ScriptBlock>
                <CustomControlName>TypePropertiesControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ScriptBlock> 
        if ($_.'.BindingFlags') {
            @{Type=$_;BindingFlags="$($_.'.BindingFlags')"}
        } else {
            $_
        }
    </ScriptBlock>
                <CustomControlName>TypeMethodsControl</CustomControlName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>System.Text.RegularExpressions.Match</Name>
      <ViewSelectedBy>
        <TypeName>System.Text.RegularExpressions.Match</TypeName>
      </ViewSelectedBy>
      <TableControl>
        <AutoSize />
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
            <Label>Length</Label>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <Wrap />
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>Index</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <ScriptBlock>1</ScriptBlock>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>Value</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>Microsoft.PowerShell.Commands.MatchInfo</Name>
      <ViewSelectedBy>
        <TypeName>Microsoft.PowerShell.Commands.MatchInfo</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>
    $matchInfo = $_
    $isFileMatch = $matchInfo.Path -and ($matchInfo.Path -ne 'InputStream')
    $currentLocation = $ExecutionContext.SessionState.Path.CurrentLocation
    $relativePath = $matchInfo.RelativePath($currentLocation)
    $originalLine = $(
        if ($matchInfo.ToEmphasizedString) {
            $matchInfo.ToEmphasizedString($currentLocation)
        } elseif ($isFileMatch) {
            $matchInfo.ToString().Replace($matchInfo.Path, $relativePath)
        } else {
            $matchInfo.ToString()
        }
    )
    
    if ($PSStyle) {
        $PoshModule = $posh
        if ($isFileMatch) {
            # Match in a file item
            $colorTable = @(
                $PSStyle.Foreground.Green
                $PSStyle.Foreground.Yellow
            )

            $colorIndex = . $PoshModule {
                # Create a module scope variable
                if (-not $script:MatchInfoColorIndex) {
                    $script:MatchInfoColorIndex = @{
                        index = 0
                        lastFilepath = $args[0]
                    }
                }
                $script:MatchInfoColorIndex
            } $relativePath
            if ($colorIndex.lastFilepath -ne $relativePath) {
                $colorIndex.index = ($colorIndex.index + 1) % $colorTable.Count
                $colorIndex.lastFilepath = $relativePath
            }

            $color = $colorTable[$colorIndex.index]
            $coloredPath = $color + $relativePath + $PSStyle.Reset
            
            if ($PSStyle.FormatHyperlink -and -not $env:GITHUB_WORKSPACE) {
                $hyperLink = $PSStyle.FormatHyperlink($coloredPath, $matchInfo.Path)
                $originalLine.Replace($relativePath, $hyperLink)
            } else {
                $originalLine.Replace($relativePath, $coloredPath)
            }
        } else {
            # Match in a text input
            $originalLine
        }
    } else {
        $originalLine
    }
</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Microsoft.PowerShell.Commands.SelectXmlInfo</Name>
      <ViewSelectedBy>
        <TypeName>Microsoft.PowerShell.Commands.SelectXmlInfo</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>Path</PropertyName>
      </GroupBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>Node</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>Pattern</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>System.Xml.XmlElement</Name>
      <ViewSelectedBy>
        <TypeName>System.Xml.XmlElement</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>$script:TreeDepth = 0;$true</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$_</ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>XmlNodeControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>$executionContext.SessionState.PSVariable.Remove("script:TreeDepth");$false</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>$null</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>System.Xml.XmlDocument</Name>
      <ViewSelectedBy>
        <TypeName>System.Xml.XmlDocument</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>$script:TreeDepth = 0;$true</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock>
    @(foreach ($cn in $_.ChildNodes) {
        if ($cn -is [xml.xmldeclaration]) { continue }
        $cn
    })
</ScriptBlock>
                <EnumerateCollection />
                <CustomControlName>XmlNodeControl</CustomControlName>
              </ExpressionBinding>
              <ExpressionBinding>
                <ItemSelectionCondition>
                  <ScriptBlock>$ExecutionContext.SessionState.PSVariable.Remove('script:TreeDepth'); $false</ScriptBlock>
                </ItemSelectionCondition>
                <ScriptBlock> $null </ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>System.Management.Automation.ApplicationInfo</Name>
      <ViewSelectedBy>
        <TypeName>System.Management.Automation.ApplicationInfo</TypeName>
      </ViewSelectedBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>Name</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>Source</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>System.Management.Automation.CommandInfo</Name>
      <ViewSelectedBy>
        <TypeName>System.Management.Automation.CommandInfo</TypeName>
        <TypeName>System.Management.Automation.AliasInfo</TypeName>
        <TypeName>System.Management.Automation.ApplicationInfo</TypeName>
        <TypeName>System.Management.Automation.CmdletInfo</TypeName>
        <TypeName>System.Management.Automation.ExternalScriptInfo</TypeName>
        <TypeName>System.Management.Automation.FilterInfo</TypeName>
        <TypeName>System.Management.Automation.FunctionInfo</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>CommandType</PropertyName>
      </GroupBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
            <Label>Name</Label>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <!-- {ConditionalStyle:"
            switch -regex ($_.Name) 
            {
                &apos;^(?&gt;Add|New)\p{P}&apos; { &apos;Foreground.Green&apos; }
                &apos;^(?&gt;Get|Test|Sort|Select|Compare)\p{P}&apos; { &apos;Foreground.Green&apos;, &apos;Bold&apos; }
                &apos;^(?&gt;Out|Format|Show)\p{P}&apos; { &apos;Foreground.Magenta&apos;, &apos;Bold&apos; }
                &apos;^(?&gt;Measure|Write|Read|Push|Pop)\p{P}&apos; { &apos;Foreground.Magenta&apos; }
                &apos;^(?&gt;Convert|Import|Export)\p{P}&apos; { &apos;Foreground.Blue&apos;, &apos;Bold&apos; }
                &apos;^(?&gt;ConvertTo|ConvertFrom|Copy)\p{P}&apos; { &apos;Foreground.BrightBlue&apos; }
                &apos;^(?&gt;Move)\p{P}&apos; { &apos;Foreground.BrightBlue&apos;,&apos;Bold&apos; }
                &apos;^(?&gt;Send|Receive)\p{P}&apos; { &apos;Foreground.BrightBlue&apos; }
                &apos;^(?&gt;Lock|Unlock|Block|Unblock)\p{P}&apos; { &apos;Foreground.BrightBlue&apos; }
                &apos;^(?&gt;Protect|Unprotect)\p{P}&apos; { &apos;Foreground.Red&apos; }
                &apos;^(?&gt;Start|Stop)\p{P}&apos;   { &apos;Foreground.Magenta&apos;, &apos;Bold&apos; }
                &apos;^(?&gt;Install|Uninstall)\p{P}&apos;   { &apos;Foreground.Magenta&apos;, &apos;Bold&apos; }
                &apos;^(?&gt;Register|Unregister)\p{P}&apos;   { &apos;Foreground.Yellow&apos; }
                &apos;^(?&gt;Connect|Disconnect)\p{P}&apos;   { &apos;Foreground.BrightBlue&apos; }
                &apos;^(?&gt;Enter|Exit)\p{P}&apos;   { &apos;Foreground.Yellow&apos; }
                &apos;^(?&gt;Wait)\p{P}&apos; { &apos;Foreground.Yellow&apos;, &apos;Italic&apos;}
                &apos;^(?&gt;Remove|Rename|Exit|Debug)\p{P}&apos; { &apos;Foreground.Red&apos;, &apos;Bold&apos; }
                &apos;^(?&gt;Invoke|Use)\p{P}&apos; { &apos;Foreground.BrightYellow&apos;, &apos;Italic&apos;}
                &apos;^(?&gt;Set|Restart|Reset|Update|Clear)\p{P}&apos; { &apos;Foreground.Yellow&apos; }
                &apos;^(?&gt;Enable|Resume)\p{P}&apos;  { &apos;Foreground.Green&apos; }
                &apos;^(?&gt;Disable|Suspend)\p{P}&apos; { &apos;Foreground.Yellow&apos; }
            }
        "}-->
              <TableColumnItem>
                <ScriptBlock>                        
                        $CellColorValue = $($Script:_LastCellStyle = $($__ = $_;. {
            switch -regex ($_.Name) 
            {
                '^(?&gt;Add|New)\p{P}' { 'Foreground.Green' }
                '^(?&gt;Get|Test|Sort|Select|Compare)\p{P}' { 'Foreground.Green', 'Bold' }
                '^(?&gt;Out|Format|Show)\p{P}' { 'Foreground.Magenta', 'Bold' }
                '^(?&gt;Measure|Write|Read|Push|Pop)\p{P}' { 'Foreground.Magenta' }
                '^(?&gt;Convert|Import|Export)\p{P}' { 'Foreground.Blue', 'Bold' }
                '^(?&gt;ConvertTo|ConvertFrom|Copy)\p{P}' { 'Foreground.BrightBlue' }
                '^(?&gt;Move)\p{P}' { 'Foreground.BrightBlue','Bold' }
                '^(?&gt;Send|Receive)\p{P}' { 'Foreground.BrightBlue' }
                '^(?&gt;Lock|Unlock|Block|Unblock)\p{P}' { 'Foreground.BrightBlue' }
                '^(?&gt;Protect|Unprotect)\p{P}' { 'Foreground.Red' }
                '^(?&gt;Start|Stop)\p{P}'   { 'Foreground.Magenta', 'Bold' }
                '^(?&gt;Install|Uninstall)\p{P}'   { 'Foreground.Magenta', 'Bold' }
                '^(?&gt;Register|Unregister)\p{P}'   { 'Foreground.Yellow' }
                '^(?&gt;Connect|Disconnect)\p{P}'   { 'Foreground.BrightBlue' }
                '^(?&gt;Enter|Exit)\p{P}'   { 'Foreground.Yellow' }
                '^(?&gt;Wait)\p{P}' { 'Foreground.Yellow', 'Italic'}
                '^(?&gt;Remove|Rename|Exit|Debug)\p{P}' { 'Foreground.Red', 'Bold' }
                '^(?&gt;Invoke|Use)\p{P}' { 'Foreground.BrightYellow', 'Italic'}
                '^(?&gt;Set|Restart|Reset|Update|Clear)\p{P}' { 'Foreground.Yellow' }
                '^(?&gt;Enable|Resume)\p{P}'  { 'Foreground.Green' }
                '^(?&gt;Disable|Suspend)\p{P}' { 'Foreground.Yellow' }
            }
        };$_ = $__);$Script:_LastCellStyle)
                        
                            $CellColorValue = if ($psStyle) {
                                @(foreach ($styleProp in $CellColorValue) {
                                    if ($styleProp -match '^\$') {
                                        $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
                                    }
                                    elseif ($styleProp -match '\.') {
                                        $targetObject = $psStyle
                                        foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                                            if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                                                $targetObject -is [Collections.IDictionary]) {
                                                $targetObject = $targetObject[$dotProperty]
                                            } else {
                                                $targetObject = $targetObject.$dotProperty
                                            }
                                        }
                                        if ($targetObject) {
                                            $targetObject
                                        }
                                    }
                                    else {
                                        $psStyle.$styleProp
                                    }
                                }) -join ''
                            }
                                                    
                        $output = . {$_.'Name'}
                        @($CellColorValue; $output; $psStyle.Reset) -join ''
                        </ScriptBlock>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>Module</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>Microsoft.PowerShell.Commands.MemberDefinition</Name>
      <ViewSelectedBy>
        <TypeName>Microsoft.PowerShell.Commands.MemberDefinition</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>TypeName</PropertyName>
      </GroupBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
            <Label>Name</Label>
          </TableColumnHeader>
          <TableColumnHeader>
            <Label>MemberType</Label>
          </TableColumnHeader>
          <TableColumnHeader>
            <Label>Definition</Label>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <!-- {ConditionalStyle:"
        
        @(
        if ($_.MemberType -notin &apos;Method&apos;,&apos;Property&apos;,&apos;ParemeterizedProperty&apos;) {
            &quot;Italic&quot;
        }
        if ($_.MemberType -like &apos;*property*&apos;) {        
            &quot;Foreground.Green&quot;            
            &quot;Bold&quot;
        }
        elseif ($_.MemberType -like &apos;*method&apos; -or $_.MemberType -eq &apos;Event&apos;) {
            &quot;Formatting.Warning&quot;
        })        
    "}-->
              <TableColumnItem>
                <ScriptBlock>                        
                        $CellColorValue = $($Script:_LastCellStyle = $($__ = $_;. {
        
        @(
        if ($_.MemberType -notin 'Method','Property','ParemeterizedProperty') {
            "Italic"
        }
        if ($_.MemberType -like '*property*') {        
            "Foreground.Green"            
            "Bold"
        }
        elseif ($_.MemberType -like '*method' -or $_.MemberType -eq 'Event') {
            "Formatting.Warning"
        })        
    };$_ = $__);$Script:_LastCellStyle)
                        
                            $CellColorValue = if ($psStyle) {
                                @(foreach ($styleProp in $CellColorValue) {
                                    if ($styleProp -match '^\$') {
                                        $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
                                    }
                                    elseif ($styleProp -match '\.') {
                                        $targetObject = $psStyle
                                        foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                                            if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                                                $targetObject -is [Collections.IDictionary]) {
                                                $targetObject = $targetObject[$dotProperty]
                                            } else {
                                                $targetObject = $targetObject.$dotProperty
                                            }
                                        }
                                        if ($targetObject) {
                                            $targetObject
                                        }
                                    }
                                    else {
                                        $psStyle.$styleProp
                                    }
                                }) -join ''
                            }
                                                    
                        $output = . {$_.'Name'}
                        @($CellColorValue; $output; $psStyle.Reset) -join ''
                        </ScriptBlock>
              </TableColumnItem>
              <!-- {ConditionalStyle:"
        
        @(
        if ($_.MemberType -notin &apos;Method&apos;,&apos;Property&apos;,&apos;ParemeterizedProperty&apos;) {
            &quot;Italic&quot;
        }
        if ($_.MemberType -like &apos;*property*&apos;) {        
            &quot;Foreground.Green&quot;            
            &quot;Bold&quot;
        }
        elseif ($_.MemberType -like &apos;*method&apos; -or $_.MemberType -eq &apos;Event&apos;) {
            &quot;Formatting.Warning&quot;
        })        
    "}-->
              <TableColumnItem>
                <ScriptBlock>                        
                        $CellColorValue = $($Script:_LastCellStyle = $($__ = $_;. {
        
        @(
        if ($_.MemberType -notin 'Method','Property','ParemeterizedProperty') {
            "Italic"
        }
        if ($_.MemberType -like '*property*') {        
            "Foreground.Green"            
            "Bold"
        }
        elseif ($_.MemberType -like '*method' -or $_.MemberType -eq 'Event') {
            "Formatting.Warning"
        })        
    };$_ = $__);$Script:_LastCellStyle)
                        
                            $CellColorValue = if ($psStyle) {
                                @(foreach ($styleProp in $CellColorValue) {
                                    if ($styleProp -match '^\$') {
                                        $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
                                    }
                                    elseif ($styleProp -match '\.') {
                                        $targetObject = $psStyle
                                        foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                                            if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                                                $targetObject -is [Collections.IDictionary]) {
                                                $targetObject = $targetObject[$dotProperty]
                                            } else {
                                                $targetObject = $targetObject.$dotProperty
                                            }
                                        }
                                        if ($targetObject) {
                                            $targetObject
                                        }
                                    }
                                    else {
                                        $psStyle.$styleProp
                                    }
                                }) -join ''
                            }
                                                    
                        $output = . {$_.'MemberType'}
                        @($CellColorValue; $output; $psStyle.Reset) -join ''
                        </ScriptBlock>
              </TableColumnItem>
              <TableColumnItem>
                <ScriptBlock>
        $findOverloads = [Regex]::new('(?&lt;=^|\))[\s\p{P}]{0,}(?&lt;Type&gt;\S{1,})\s{1,}(?&lt;Name&gt;\w{1,})', 'IgnoreCase', '00:00:01')
        $definition = $_.definition
        $memberInfo = $_
        $foundOverloads = @(foreach ($m in $findOverloads.Matches($Definition)) {$m.Groups["Type","Name"]})
        
        
        $chars         = $definition.ToCharArray()
        $overload      = $null
        $overloadIndex = 0
        $innerDepth = 0
        $overloadTypeDefined = $false
        @(for($i = 0; $i -lt $chars.length; $i++) {
            if (-not $overload) {
                if ($foundOverloads[$overloadIndex].Index -eq $i) {                    
                    $overload = $foundOverloads[$overloadIndex]
                    if ($overload.Name -eq 'Type') {
                        if ($psStyle) {
                            $psStyle.Foreground.BrightCyan
                            $psStyle.Foreground.Bold
                        }
                    } else {
                        if ($psStyle) {
                            $psStyle.Formatting.Warning
                        }
                        
                    }
                    $overloadTypeDefined = $false
                }

            }
            switch ($chars[$i]) {
                '(' {
                    if ($psStyle) {$psStyle.Formatting.Warning}
                    '('
                    if ($psStyle) {$psStyle.Reset}
                    $innerDepth++
                }
                ')' {
                    if ($psStyle) {$psStyle.Formatting.Warning}
                    ')'
                    if ($psStyle) {$psStyle.Reset}
                    $innerDepth--                    
                }
                '{' {
                    if ($psStyle) {$psStyle.Foreground.Magenta;$psStyle.Foreground.Bold}
                    '{'
                    if ($psStyle) {$psStyle.Reset}
                    $innerDepth++
                }
                '}' {
                    if ($psStyle) {$psStyle.Foreground.Magenta;$psStyle.Foreground.Bold}
                    $innerDepth--
                    '}'
                    if ($psStyle) {$psStyle.Reset}                    
                }
                ';' {
                    if ($psStyle) {$psStyle.Foreground.BrightCyan}
                    ';'
                    if ($psStyle) {$psStyle.Reset}
                }
                
                ',' {
                    
                    if ($psStyle) {
                        $psStyle.Foreground.BrightCyan
                    }
                    ','
                    if ($psStyle) {
                        $psStyle.Reset
                    }
                
                    
                }
                
                default {
                    if ($memberInfo.MemberType -eq 'ScriptMethod') {
                        if (-not $innerDepth) {
                            $chars[$i]
                        }
                    }  else {
                        $chars[$i]
                    }
                    
                }
            }
            
            
            if ($overload -and ($i -eq ($overload.Index + $overload.Length))) {
                $overload = $null
                $overloadIndex++
                if ($psStyle) {
                    $psStyle.Reset
                }
            }
            
        }) -join ''
    </ScriptBlock>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>System.Management.Automation.PSVariable</Name>
      <ViewSelectedBy>
        <TypeName>System.Management.Automation.PSVariable</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <ScriptBlock>
    "In $($psStyle.Foreground.Green;$psStyle.Bold)Bold Green$($psStyle.Foreground.Reset)"    
</ScriptBlock>
        <Label>ReadOnly / Constant Variables</Label>
      </GroupBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
            <Label>Name</Label>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <!-- {ConditionalStyle:"
        if ($_.Options -band &apos;ReadOnly&apos; -or $_.Options -band &apos;Constant&apos;) {
            &quot;Bold&quot;, &quot;Foreground.Green&quot;
        }        
    "}-->
              <TableColumnItem>
                <ScriptBlock>                        
                        $CellColorValue = $($Script:_LastCellStyle = $($__ = $_;. {
        if ($_.Options -band 'ReadOnly' -or $_.Options -band 'Constant') {
            "Bold", "Foreground.Green"
        }        
    };$_ = $__);$Script:_LastCellStyle)
                        
                            $CellColorValue = if ($psStyle) {
                                @(foreach ($styleProp in $CellColorValue) {
                                    if ($styleProp -match '^\$') {
                                        $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
                                    }
                                    elseif ($styleProp -match '\.') {
                                        $targetObject = $psStyle
                                        foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                                            if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                                                $targetObject -is [Collections.IDictionary]) {
                                                $targetObject = $targetObject[$dotProperty]
                                            } else {
                                                $targetObject = $targetObject.$dotProperty
                                            }
                                        }
                                        if ($targetObject) {
                                            $targetObject
                                        }
                                    }
                                    else {
                                        $psStyle.$styleProp
                                    }
                                }) -join ''
                            }
                                                    
                        $output = . {$_.'Name'}
                        @($CellColorValue; $output; $psStyle.Reset) -join ''
                        </ScriptBlock>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>Value</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>System.Text.RegularExpressions.RegEx</Name>
      <ViewSelectedBy>
        <TypeName>System.Text.RegularExpressions.RegEx</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>
    $pattern = "$($_.ToString())"
    @(for ($i = 0; $i -lt $pattern.Length; $i++) {
        if ($pattern[$i -1] -eq '\') {
            if ($pattern[$i -2] -ne '\' -or ($pattern[$i -2] -eq '\' -and $pattern[$i -3] -eq '\')) {
                $pattern[$i]
                continue
            }
        }
        if ($i -and $pattern[$i] -eq '?' -and $pattern[$i + 1] -eq '&lt;' -and $pattern[$i + 2] -match '[\w\-]') {
            # Group name
            if ($psStyle) {
                $psStyle.Foreground.Green
                $psStyle.Bold
            }                        
            $nameEnd = $pattern.IndexOf('&gt;', $i)
            $pattern.Substring($i, 2)
            if ($psStyle) {
                $psStyle.Underline
            }
            
            $pattern.Substring($i + 2, $nameEnd - ($i + 2))
            if ($psStyle) {
                $psStyle.UnderlineOff
            }
            $i = $nameEnd
            '&gt;'
            if ($psStyle) { $psStyle.Reset }
            continue
        }

        if ('(',')','[',']' -contains $pattern[$i]) {
            # Grouping paranthesis
            if ($psStyle) {
                $psStyle.Foreground.Yellow;$psStyle.Bold
                # . $SetOutputStyle -ForegroundColor Warning &lt;#Irregular.Regex.Group#&gt; -Bold
            }
            
            $pattern[$i]
            if ($psStyle) { $psStyle.Reset }            
            continue
        }

        if ('|','?','&lt;','&gt;','!' -contains $pattern[$i]) {
            if ($psStyle) { $psStyle.Formatting.Verbose }
            $pattern[$i]
            if ($psStyle) { $psStyle.Reset }            
            continue
        }

        if ($pattern[$i] -eq '#') {
            if ($psStyle) {
                $psStyle.Foreground.Green
                $psStyle.Bold
            }
            # . $SetOutputStyle -ForegroundColor Success # Irregular.Regex.Comment
            $lineEnd = $pattern.IndexOfAny([Environment]::NewLine.ToCharArray(), $i)
            if (($lineEnd - $i) -gt 0) {
                $pattern.Substring($i, $lineEnd -$i)
                $i = $lineEnd - 1

            } else {
                $pattern.Substring($i)
                $i = $pattern.Length
            }
            if ($psStyle) {
                $psStyle.Reset
            }            
            continue
        }


        $pattern[$i]
    }) -join ''

</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>System.Text.RegularExpressions.RegEx</Name>
      <ViewSelectedBy>
        <TypeName>System.Text.RegularExpressions.RegEx</TypeName>
      </ViewSelectedBy>
      <ListControl>
        <ListEntries>
          <ListEntry>
            <ListItems>
              <ListItem>
                <PropertyName>GroupNames</PropertyName>
              </ListItem>
              <ListItem>
                <PropertyName>Pattern</PropertyName>
              </ListItem>
              <ListItem>
                <PropertyName>Options</PropertyName>
              </ListItem>
              <ListItem>
                <PropertyName>MatchTimeout</PropertyName>
              </ListItem>
            </ListItems>
          </ListEntry>
        </ListEntries>
      </ListControl>
    </View>
    <View>
      <Name>System.Text.RegularExpressions.RegEx</Name>
      <ViewSelectedBy>
        <TypeName>System.Text.RegularExpressions.RegEx</TypeName>
      </ViewSelectedBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <Wrap />
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>Pattern</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>GroupNames</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>System.Management.Automation.PSModuleInfo</Name>
      <ViewSelectedBy>
        <TypeName>System.Management.Automation.PSModuleInfo</TypeName>
        <TypeName>Posh.RichModuleInfo</TypeName>
      </ViewSelectedBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
            <Label>ExportedCommands</Label>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>Name</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>Version</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>PreRelease</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <ScriptBlock> $_.ExportedCommands.Values </ScriptBlock>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>System.Management.Automation.PSModuleInfo</Name>
      <ViewSelectedBy>
        <TypeName>System.Management.Automation.PSModuleInfo</TypeName>
        <TypeName>Posh.RichModuleInfo</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>$moduleName = 'Posh'

            do {
                $lm = Get-Module -Name $moduleName -ErrorAction Ignore
                if (-not $lm) { continue } 
                if ($lm.FormatPartsLoaded) { break }
                $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
                    foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
                        $ParentNode = $partNodeName.Node.ParentNode
                        "$($ParentNode.Name)={
            $($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
                    }
                }) -join [Environment]::NewLine
                New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
                    Import-Module -Global
                $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
                
                if (-not $lm.OnRemove) {
                    $lm.OnRemove = $onRemove
                } else {
                    $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
                }
                $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force
            
            } while ($false)
            
        

$module = $_
@(
    $moduleNameVer = $module.Name + $(
        if ($module.Version) {
            " [$($module.Version)]"
        }
    )
    &amp; ${Posh_Format-Markdown} -Heading $moduleNameVer -HeadingSize 1
    if ($module.Description) {
        &amp; ${Posh_Format-Markdown} -Heading $module.Description -HeadingSize 2
    }

    $commandSection = 
        if ($module.ExportedCommands.Count) {
            $sortedByVerb = $module.ExportedCommands.Values |
                Where-Object { $_.Verb -and $_.Noun } |
                Sort-Object Verb, Noun |
                Select-Object Verb, Noun
            
            $sortedByVerb | &amp; ${Posh_Format-Markdown} -MarkdownTable
        }

    if ($commandSection) {
        $commandLineLength = $commandSection | Measure-Object -Property Length -Maximum | Select-Object -ExpandProperty Maximum
        "### Commands"        
        $commandSection -join [Environment]::NewLine        
    }

    :findAboutText foreach ($culture in "$(Get-Culture)", 'en-us'| Select-Object -Unique) {
        $aboutTextFile = $module |
            Split-Path |
            Join-Path -ChildPath $culture |
            Join-Path -ChildPath "About_$module.help.txt"
        if (Test-Path $aboutTextFile) {
            [IO.File]::ReadAllText("$aboutTextFile")
            break
        } else {
            Write-Verbose "No help.txt file found at $aboutTextFile"
        }
    }
) -join [Environment]::NewLine
</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Process.Heatmap</Name>
      <ViewSelectedBy>
        <TypeName>System.Diagnostics.Process</TypeName>
      </ViewSelectedBy>
      <TableControl>
        <TableHeaders>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
            <Label>NPM(K)</Label>
          </TableColumnHeader>
          <TableColumnHeader>
            <Label>PM(K)</Label>
          </TableColumnHeader>
          <TableColumnHeader>
            <Label>WS(K)</Label>
          </TableColumnHeader>
          <TableColumnHeader>
            <Label>CPU(S)</Label>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
          <TableColumnHeader>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <PropertyName>Handles</PropertyName>
              </TableColumnItem>
              <!-- {ConditionalColor:"
        Format-Heatmap -InputObject $_.NPM -HeatMapMin 16mb -HeatMapMiddle .5gb -HeatMapMax 1gb 
    "}-->
              <TableColumnItem>
                <ScriptBlock>$moduleName = 'Posh'

            do {
                $lm = Get-Module -Name $moduleName -ErrorAction Ignore
                if (-not $lm) { continue } 
                if ($lm.FormatPartsLoaded) { break }
                $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
                    foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
                        $ParentNode = $partNodeName.Node.ParentNode
                        "$($ParentNode.Name)={
            $($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
                    }
                }) -join [Environment]::NewLine
                New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
                    Import-Module -Global
                $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
                
                if (-not $lm.OnRemove) {
                    $lm.OnRemove = $onRemove
                } else {
                    $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
                }
                $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force
            
            } while ($false)
            
        
                        
                        $CellColorValue = $($Script:_LastCellStyle = $($__ = $_;. {
        &amp; ${Posh_Format-Heatmap} -InputObject $_.NPM -HeatMapMin 16mb -HeatMapMiddle .5gb -HeatMapMax 1gb 
    };$_ = $__);$Script:_LastCellStyle)
                        
                            if ($CellColorValue -and $CellColorValue -is [string]) {
                                $CellColorValue = &amp; ${Posh_Format-RichText} -NoClear -ForegroundColor $CellColorValue
                            } elseif (`$CellColorValue -is [Collections.IDictionary]) {
                                $CellColorValue = &amp; ${Posh_Format-RichText} -NoClear @CellColorValue
                            }
                                                    
                        $output = . { [long]($_.NPM / 1024) }
                        @($CellColorValue; $output; &amp; ${Posh_Format-RichText}) -join ''
                        </ScriptBlock>
              </TableColumnItem>
              <!-- {ConditionalColor:" 
        Format-Heatmap -InputObject $_.PM -HeatMapMin 16mb -HeatMapMiddle .5GB -HeatMapMax 1gb 
    "}-->
              <TableColumnItem>
                <ScriptBlock>                        
                        $CellColorValue = $($Script:_LastCellStyle = $($__ = $_;. { 
        &amp; ${Posh_Format-Heatmap} -InputObject $_.PM -HeatMapMin 16mb -HeatMapMiddle .5GB -HeatMapMax 1gb 
    };$_ = $__);$Script:_LastCellStyle)
                        
                            if ($CellColorValue -and $CellColorValue -is [string]) {
                                $CellColorValue = &amp; ${Posh_Format-RichText} -NoClear -ForegroundColor $CellColorValue
                            } elseif (`$CellColorValue -is [Collections.IDictionary]) {
                                $CellColorValue = &amp; ${Posh_Format-RichText} -NoClear @CellColorValue
                            }
                                                    
                        $output = . { [long]($_.PM / 1024) }
                        @($CellColorValue; $output; &amp; ${Posh_Format-RichText}) -join ''
                        </ScriptBlock>
              </TableColumnItem>
              <!-- {ConditionalColor:"
        Format-Heatmap -InputObject $_.WS -HeatMapMin 16mb -HeatMapMiddle 512mb -HeatMapMax 1gb 
    "}-->
              <TableColumnItem>
                <ScriptBlock>                        
                        $CellColorValue = $($Script:_LastCellStyle = $($__ = $_;. {
        &amp; ${Posh_Format-Heatmap} -InputObject $_.WS -HeatMapMin 16mb -HeatMapMiddle 512mb -HeatMapMax 1gb 
    };$_ = $__);$Script:_LastCellStyle)
                        
                            if ($CellColorValue -and $CellColorValue -is [string]) {
                                $CellColorValue = &amp; ${Posh_Format-RichText} -NoClear -ForegroundColor $CellColorValue
                            } elseif (`$CellColorValue -is [Collections.IDictionary]) {
                                $CellColorValue = &amp; ${Posh_Format-RichText} -NoClear @CellColorValue
                            }
                                                    
                        $output = . { [long]($_.WS / 1024) }
                        @($CellColorValue; $output; &amp; ${Posh_Format-RichText}) -join ''
                        </ScriptBlock>
              </TableColumnItem>
              <TableColumnItem>
                <ScriptBlock> 
        if ($_.CPU -ne $()) { 
            $_.CPU.ToString("N") 
        }
    </ScriptBlock>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>ID</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>SI</PropertyName>
              </TableColumnItem>
              <TableColumnItem>
                <PropertyName>ProcessName</PropertyName>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
    <View>
      <Name>process</Name>
      <ViewSelectedBy>
        <TypeName>System.Diagnostics.Process</TypeName>
      </ViewSelectedBy>
      <GroupBy>
        <PropertyName>ProcessName</PropertyName>
        <CustomControlName>ProcessGroupControl</CustomControlName>
      </GroupBy>
      <ListControl>
        <ListEntries>
          <ListEntry>
            <ListItems>
              <ListItem>
                <PropertyName>ID</PropertyName>
              </ListItem>
            </ListItems>
          </ListEntry>
        </ListEntries>
      </ListControl>
    </View>
    <View>
      <Name>System.Version</Name>
      <ViewSelectedBy>
        <TypeName>System.Version</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock> $_ </ScriptBlock>
                <CustomControlName>VersionControl</CustomControlName>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>Default</Name>
      <ViewSelectedBy>
        <TypeName>System.TimeSpan</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>"$_"</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>ISO-8601</Name>
      <ViewSelectedBy>
        <TypeName>System.TimeSpan</TypeName>
      </ViewSelectedBy>
      <CustomControl>
        <CustomEntries>
          <CustomEntry>
            <CustomItem>
              <ExpressionBinding>
                <ScriptBlock>   
    $timespan = $_
    @(
        "P"
        if ([Math]::floor($timespan.TotalDays) -gt 0) {
            [Math]::floor($timespan.TotalDays)
            "D"
        }
        "T"
        if ([Math]::floor($timespan.TotalHours) -gt 0) {
            [Math]::floor($timespan.TotalHours % 24)
            "H"
        }
        if ([Math]::floor($timespan.TotalMinutes) -gt 0) {
            [Math]::floor($timespan.TotalMinutes % 60)
            "M"
        }
        if ([Math]::floor($timespan.TotalSeconds) -gt 0) {
            [Math]::floor($timespan.TotalSeconds % 60)
            "S"
        }
    ) -join ''
</ScriptBlock>
              </ExpressionBinding>
            </CustomItem>
          </CustomEntry>
        </CustomEntries>
      </CustomControl>
    </View>
    <View>
      <Name>System.TimeZoneInfo</Name>
      <ViewSelectedBy>
        <TypeName>System.TimeZoneInfo</TypeName>
      </ViewSelectedBy>
      <TableControl>
        <AutoSize />
        <TableHeaders>
          <TableColumnHeader>
            <Label>ID</Label>
            <Alignment>Right</Alignment>
          </TableColumnHeader>
          <TableColumnHeader>
            <Label>LocalTime</Label>
            <Alignment>Center</Alignment>
          </TableColumnHeader>
          <TableColumnHeader>
            <Label>DisplayName</Label>
            <Alignment>Left</Alignment>
          </TableColumnHeader>
        </TableHeaders>
        <TableRowEntries>
          <TableRowEntry>
            <TableColumnItems>
              <TableColumnItem>
                <ScriptBlock>                        
                        $CellColorValue = $($Script:_LastCellStyle = $($__ = $_;. {
    if ($_.LocalTime.Hour -lt 6 -or $_.LocalTime.Hour -gt 18) {
        'Foreground.Blue','Italic'
    }
    else {
        'Foreground.Yellow','Bold'
    }
};$_ = $__);$Script:_LastCellStyle)
                        
                            $CellColorValue = if ($psStyle) {
                                @(foreach ($styleProp in $CellColorValue) {
                                    if ($styleProp -match '^\$') {
                                        $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
                                    }
                                    elseif ($styleProp -match '\.') {
                                        $targetObject = $psStyle
                                        foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                                            if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                                                $targetObject -is [Collections.IDictionary]) {
                                                $targetObject = $targetObject[$dotProperty]
                                            } else {
                                                $targetObject = $targetObject.$dotProperty
                                            }
                                        }
                                        if ($targetObject) {
                                            $targetObject
                                        }
                                    }
                                    else {
                                        $psStyle.$styleProp
                                    }
                                }) -join ''
                            }
                                                    
                        $output = . {$_.'ID'}
                        @($CellColorValue; $output; $psStyle.Reset) -join ''
                        </ScriptBlock>
              </TableColumnItem>
              <TableColumnItem>
                <ScriptBlock>                        
                        $CellColorValue = $Script:_LastCellStyle
                        
                            $CellColorValue = if ($psStyle) {
                                @(foreach ($styleProp in $CellColorValue) {
                                    if ($styleProp -match '^\$') {
                                        $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
                                    }
                                    elseif ($styleProp -match '\.') {
                                        $targetObject = $psStyle
                                        foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                                            if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                                                $targetObject -is [Collections.IDictionary]) {
                                                $targetObject = $targetObject[$dotProperty]
                                            } else {
                                                $targetObject = $targetObject.$dotProperty
                                            }
                                        }
                                        if ($targetObject) {
                                            $targetObject
                                        }
                                    }
                                    else {
                                        $psStyle.$styleProp
                                    }
                                }) -join ''
                            }
                                                    
                        $output = . { 
        ' ' + $_.LocalTime.ToShortTimeString() + ' '
    }
                        @($CellColorValue; $output; $psStyle.Reset) -join ''
                        </ScriptBlock>
              </TableColumnItem>
              <TableColumnItem>
                <ScriptBlock>                        
                        $CellColorValue = $Script:_LastCellStyle
                        
                            $CellColorValue = if ($psStyle) {
                                @(foreach ($styleProp in $CellColorValue) {
                                    if ($styleProp -match '^\$') {
                                        $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
                                    }
                                    elseif ($styleProp -match '\.') {
                                        $targetObject = $psStyle
                                        foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                                            if ($targetObject.Item -is [Management.Automation.PSMethodInfo] -or 
                                                $targetObject -is [Collections.IDictionary]) {
                                                $targetObject = $targetObject[$dotProperty]
                                            } else {
                                                $targetObject = $targetObject.$dotProperty
                                            }
                                        }
                                        if ($targetObject) {
                                            $targetObject
                                        }
                                    }
                                    else {
                                        $psStyle.$styleProp
                                    }
                                }) -join ''
                            }
                                                    
                        $output = . {$_.'DisplayName'}
                        @($CellColorValue; $output; $psStyle.Reset) -join ''
                        </ScriptBlock>
              </TableColumnItem>
            </TableColumnItems>
          </TableRowEntry>
        </TableRowEntries>
      </TableControl>
    </View>
  </ViewDefinitions>
</Configuration>
